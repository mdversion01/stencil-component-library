/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { DropdownItem } from "./components/dropdown/dropdown-types";
import { Field, SelectMode, SortOrder, Variant } from "./components/table/table-component";
import { ToastItem, ToastPosition, ToastVariant } from "./components/toasts/toasts-component";
import { ToggleItem } from "./components/toggle-switch/toggle-switch-types";
import { TooltipPosition, TooltipVariant } from "./components/tooltip/tooltip-component";
export { DropdownItem } from "./components/dropdown/dropdown-types";
export { Field, SelectMode, SortOrder, Variant } from "./components/table/table-component";
export { ToastItem, ToastPosition, ToastVariant } from "./components/toasts/toasts-component";
export { ToggleItem } from "./components/toggle-switch/toggle-switch-types";
export { TooltipPosition, TooltipVariant } from "./components/tooltip/tooltip-component";
export namespace Components {
    interface AccordionComponent {
        "accordion": boolean;
        "block": boolean;
        "classNames": string;
        "contentTxtSize": string;
        "disabled": boolean;
        "flush": boolean;
        "icon": string;
        "isOpen": boolean;
        "link": boolean;
        "outlined": boolean;
        "ripple": boolean;
        "size": string;
        "targetId": string;
        "variant": string;
    }
    interface AccordionContainer {
        "block": boolean;
        "classNames": string;
        "contentTxtSize": string;
        "data": Array<{ header: string; content: string }>;
        "disabled": boolean;
        "flush": boolean;
        "icon": string;
        "outlined": boolean;
        "parentId": string;
        "ripple": boolean;
        "singleOpen": boolean;
        "size": string;
        "variant": string;
    }
    interface AppWrapper {
        /**
          * Optional classNames (e.g. bg-primary, p-4)
         */
        "classNames": string;
    }
    interface AutocompleteMultipleSelections {
        "addBtn": boolean;
        "addIcon": string;
        "addNewOnEnter": boolean;
        "arialabelledBy": string;
        "autoSort": boolean;
        "badgeInlineStyles": string;
        "badgeShape": string;
        "badgeVariant": string;
        "clearIcon": string;
        "clearInputOnBlurOutside": boolean;
        "devMode": boolean;
        "disabled": boolean;
        "editable": boolean;
        "error": boolean;
        "errorMessage": string;
        "formId": string;
        "formLayout": '' | 'horizontal' | 'inline';
        "inputCol": number;
        "inputCols": string;
        "inputId": string;
        "label": string;
        "labelAlign": '' | 'right';
        "labelCol": number;
        /**
          * Responsive columns (e.g., "col", "col-sm-3 col-md-4", "xs-12 sm-6 md-4")
         */
        "labelCols": string;
        "labelHidden": boolean;
        "labelSize": '' | 'sm' | 'lg';
        /**
          * Field name for selected items; if it ends with [] one input per item is emitted.
         */
        "name"?: string;
        "navigateOptions": (direction: number) => Promise<void>;
        "options": string[];
        "placeholder": string;
        "preserveInputOnSelect"?: boolean;
        /**
          * Also submit whatever the user typed under this name (verbatim).
         */
        "rawInputName"?: string;
        "removeBtnBorder": boolean;
        "removeClearBtn": boolean;
        "required": boolean;
        "size": '' | 'sm' | 'lg';
        "type": string;
        "validation": boolean;
        "validationMessage": string;
    }
    interface AutocompleteMultiselect {
        "addBtn": boolean;
        "addIcon": string;
        "addNewOnEnter": boolean;
        "arialabelledBy": string;
        "autoSort": boolean;
        "badgeInlineStyles": string;
        "badgeShape": string;
        "badgeVariant": string;
        "clearIcon": string;
        "clearInputOnBlurOutside": boolean;
        "devMode": boolean;
        "disabled": boolean;
        "editable": boolean;
        "error": boolean;
        "errorMessage": string;
        "filterOptions": () => Promise<void>;
        "formId": string;
        "formLayout": '' | 'horizontal' | 'inline';
        /**
          * ðŸ”Ž Read current options from the component (for hosts).
         */
        "getOptions": () => Promise<string[]>;
        "inputCol": number;
        "inputCols": string;
        "inputId": string;
        "label": string;
        "labelAlign": '' | 'right';
        "labelCol": number;
        /**
          * Responsive column class specs (e.g., "col", "col-sm-3 col-md-4", or "xs-12 sm-6 md-4")
         */
        "labelCols": string;
        "labelHidden": boolean;
        "labelSize": '' | 'sm' | 'lg';
        "name"?: string;
        "navigateOptions": (direction: number) => Promise<void>;
        "options": string[];
        "placeholder": string;
        "preserveInputOnSelect"?: boolean;
        "rawInputName"?: string;
        "removeClearBtn": boolean;
        "required": boolean;
        /**
          * ðŸ”§ Replace options from the host (for hosts). Also emits optionsChange('replace').
         */
        "setOptions": (next: string[]) => Promise<void>;
        "size": '' | 'sm' | 'lg';
        "type": string;
        "validation": boolean;
        "validationMessage": string;
    }
    interface AutocompleteSingle {
        "arialabelledBy": string;
        "autoSort": boolean;
        "clearIcon": string;
        "devMode": boolean;
        "disabled": boolean;
        "error": boolean;
        "errorMessage": string;
        "formId": string;
        "formLayout": '' | 'horizontal' | 'inline';
        "inputCol": number;
        "inputCols": string;
        "inputId": string;
        "label": string;
        "labelAlign": '' | 'right';
        /**
          * Back-compat numeric columns (used only if labelCols/inputCols are not provided)
         */
        "labelCol": number;
        /**
          * Responsive column class specs (e.g., "col", "col-sm-3 col-md-4", or "xs-12 sm-6 md-4")
         */
        "labelCols": string;
        "labelHidden": boolean;
        "labelSize": '' | 'sm' | 'lg';
        "options": string[];
        "placeholder": string;
        "removeClearBtn": boolean;
        "required": boolean;
        "size": '' | 'sm' | 'lg';
        "type": string;
        "validation": boolean;
        "validationMessage": string;
    }
    interface BadgeComponent {
        "absolute": boolean;
        "ariaDescribedby"?: string;
        "ariaLabelledby"?: string;
        "backgroundColor": string;
        "bdgPosition": string;
        "bordered": boolean;
        "bottom": string;
        "classNames": string;
        "color": string;
        "devMode": boolean;
        "disabled": boolean;
        "dot": boolean;
        "elevation": string;
        "icon": boolean;
        "inlineStyles": string;
        "inset": boolean;
        "label": string;
        "left": string;
        "offsetX": string;
        "offsetY": string;
        "outlined": boolean;
        "pulse": boolean;
        "right": string;
        "shape": string;
        "size": string;
        "styles": string;
        "token": boolean;
        "top": string;
        "variant": string;
        "zIndex": string;
    }
    interface BasicSliderComponent {
        "disabled": boolean;
        "hideLeftTextBox": boolean;
        "hideRightTextBox": boolean;
        "hideTextBoxes": boolean;
        "label": string;
        "max": number;
        "min": number;
        "plumage": boolean;
        "sliderThumbLabel": boolean;
        "snapToTicks": boolean;
        "tickLabels": boolean;
        /**
          * Accepts array or JSON string in HTML
         */
        "tickValues": number[] | string;
        "ticks": number | '';
        "unit": string;
        "value": number;
        "variant": '' | 'primary' | 'secondary' | 'success' | 'danger' | 'info' | 'warning' | 'dark';
    }
    interface ButtonComponent {
        "absolute": boolean;
        "accordion": boolean;
        "active": boolean;
        "ariaLabel": string;
        "block": boolean;
        "bottom": string;
        "btnIcon": boolean;
        "btnText": string;
        "classNames": string;
        "devMode": boolean;
        "disabled": boolean;
        "elevation": string;
        "end": boolean;
        "fixed": boolean;
        "groupBtn": boolean;
        "iconBtn": boolean;
        "isOpen": boolean;
        "left": string;
        "link": boolean;
        "outlined": boolean;
        "pressed": boolean | string;
        "right": string;
        "ripple": boolean;
        "shape": string;
        "size": string;
        "slotSide": 'left' | 'right' | 'none';
        "start": boolean;
        "stripped": boolean;
        "styles": string;
        "targetId": string;
        "text": boolean;
        "textBtn": boolean;
        "titleAttr": string;
        "top": string;
        "url": string;
        "variant": string;
        "vertical": boolean;
        "zIndex": string;
    }
    interface ButtonGroup {
        "ariaLabel": string;
        "classNames": string;
        "vertical": boolean;
    }
    interface ByPagePaginationComponent {
        "controlId"?: string;
        "currentPage": number;
        "goToButtons": string;
        "paginationLayout": '' | 'center' | 'end';
        "plumage": boolean;
        "size": '' | 'sm' | 'lg';
        "totalPages": number;
    }
    interface CardComponent {
        "actions": boolean;
        "altText": string;
        "ariaLabel": string;
        "cardMaxWidth": string;
        "classNames": string;
        "elevation": string;
        "img": boolean;
        "imgHeight": string;
        "imgSrc": string;
        "inlineStyles": string;
        "noFooter": boolean;
        "noHeader": boolean;
        "tab"?: string;
    }
    interface CheckboxComponent {
        "checkbox": boolean;
        "checkboxGroup": boolean;
        "checked": boolean;
        "customCheckbox": boolean;
        "customCheckboxGroup": boolean;
        "disabled": boolean;
        "groupOptions": any;
        "groupTitle": string;
        "groupTitleSize": string;
        "inline": boolean;
        "inputId": string;
        "labelTxt": string;
        "name": string;
        "noPadding": boolean;
        "required": boolean;
        "size": string;
        "validation": boolean;
        "validationMsg": string;
        "value": string;
    }
    interface DiscreteSliderComponent {
        "disabled": boolean;
        "hideRightTextBox": boolean;
        "label": string;
        "plumage": boolean;
        "selectedIndex": number;
        /**
          * Accepts array or JSON string in HTML
         */
        "stringValues": string[] | string;
        "tickLabels": boolean;
        "unit": string;
        "variant": '' | 'primary' | 'secondary' | 'success' | 'danger' | 'info' | 'warning' | 'dark';
    }
    interface DividerComponent {
        "dashed": boolean;
        "orientation"?: 'left' | 'right' | 'center';
        "orientationMargin"?: string;
        "plain": boolean;
        "styles"?: string;
        "type": 'horizontal' | 'vertical';
    }
    interface DropdownComponent {
        "alignMenuRight": boolean;
        "autoFocusSubmenu": boolean;
        "buttonText": string;
        "disabled": boolean;
        "icon": string;
        "iconDropdown": boolean;
        "iconSize"?: number;
        "inputId": string;
        "listType": string;
        "menuOffsetY": number;
        "name": string;
        "options": DropdownItem[];
        "outlined": boolean;
        "ripple": boolean;
        "shape": string;
        "size": string;
        "subMenuListType": string;
        "submenuOffsetX": number;
        "tableId": string;
        "titleAttr": string;
        "value": string;
        "variant": string;
    }
    interface FormComponent {
        /**
          * Native form attributes
         */
        "action": string;
        /**
          * Optional border/box styling
         */
        "bcolor": string;
        "bradius"?: number;
        "bstyle": string;
        "bwidth"?: number;
        /**
          * Render a fieldset wrapper (with optional legend)
         */
        "fieldset": boolean;
        "formId": string;
        /**
          * Layout + identity used by slotted children
         */
        "formLayout": '' | 'horizontal' | 'inline';
        "legend": boolean;
        "legendPosition": 'left' | 'center' | 'right' | string;
        "legendTxt": string;
        "method": string;
        /**
          * If true, do not render a <form>. Inputs placed outside the form can still read formId via closest('form-component') and set their own form attribute.
         */
        "outsideOfForm": boolean;
        /**
          * Additional inline styles to append (CSS string)
         */
        "styles": string;
    }
    interface IconComponent {
        "color"?: string;
        "icon": string;
        "iconAriaHidden": boolean;
        "iconAriaLabel"?: string;
        "iconMargin": string;
        "iconSize"?: number;
        "size": string;
        "svg": boolean;
        "tokenIcon": boolean;
    }
    interface InputFieldComponent {
        "disabled": boolean;
        "formId": string;
        "formLayout": '' | 'horizontal' | 'inline';
        "inputCol": number;
        "inputCols": string;
        "inputId": string;
        "label": string;
        "labelAlign": '' | 'right';
        /**
          * Legacy numeric cols (fallback)
         */
        "labelCol": number;
        /**
          * NEW: responsive column class specs (e.g., "col", "col-sm-3 col-md-4", or "xs-12 sm-6 md-4")
         */
        "labelCols": string;
        "labelHidden": boolean;
        "labelSize": '' | 'sm' | 'lg';
        "placeholder"?: string;
        "required": boolean;
        "size": '' | 'sm' | 'lg';
        "type": string;
        "validation": boolean;
        "validationMessage": string;
        "value": string;
    }
    interface InputGroupComponent {
        "appendIcon"?: string;
        "appendId": string;
        "disabled": boolean;
        "formId": string;
        "formLayout": '' | 'horizontal' | 'inline';
        "hasAppend": boolean;
        "hasPrepend": boolean;
        "icon": string;
        "inputCol": number;
        "inputCols": string;
        "inputId": string;
        /**
          * Kept for API parity; use `size` for visual sizing
         */
        "inputSize": string;
        "label": string;
        /**
          * Legacy numeric cols (fallback)
         */
        "labelCol": number;
        /**
          * NEW: responsive column class specs (e.g., "col", "col-sm-3 col-md-4", or "xs-12 sm-6 md-4")
         */
        "labelCols": string;
        "labelHidden": boolean;
        "labelSize": '' | 'sm' | 'lg';
        "otherContent": boolean;
        "placeholder": string;
        "prependIcon"?: string;
        "prependId": string;
        "required": boolean;
        "size": '' | 'sm' | 'lg';
        "type": string;
        "validation": boolean;
        "validationMessage": string;
        "value": string;
    }
    interface MinimizePaginationComponent {
        "controlId"?: string;
        "currentPage": number;
        "goToButtons": string;
        "paginationLayout": '' | 'center' | 'end';
        "plumage": boolean;
        "size": '' | 'sm' | 'lg';
        "totalPages": number;
    }
    interface ModalComponent {
        "ariaLabel": string;
        "block": boolean;
        "btnText": string;
        "cancelCloseBtn": string;
        "classNames": string;
        /**
          * Close programmatically
         */
        "close": () => Promise<void>;
        "disabled": boolean;
        "link": boolean;
        "modalFullScreen"?: 'fullscreen' | 'sm-down' | 'md-down' | 'lg-down' | 'xl-down' | 'xxl-down';
        "modalId"?: string;
        "modalSize"?: 'sm' | 'lg' | 'xl';
        "modalTitle": string;
        /**
          * Open programmatically
         */
        "open": () => Promise<void>;
        "outlined": boolean;
        "ripple": boolean;
        "scrollLongContent": boolean;
        "scrollableBody": boolean;
        "shape": string;
        "size": string;
        "titleAttr": string;
        "variant": string;
        "verticallyCentered": boolean;
    }
    interface MultiRangeSliderComponent {
        "disabled": boolean;
        "hideLeftTextBox": boolean;
        "hideRightTextBox": boolean;
        "hideTextBoxes": boolean;
        "label": string;
        "lowerValue": number;
        "max": number;
        "min": number;
        "plumage": boolean;
        "sliderThumbLabel": boolean;
        "snapToTicks": boolean;
        "tickLabels": boolean;
        /**
          * Accepts array or JSON string in HTML
         */
        "tickValues": number[] | string;
        "unit": string;
        "upperValue": number;
        "variant": '' | 'primary' | 'secondary' | 'success' | 'danger' | 'info' | 'warning' | 'dark';
    }
    interface PaginationComponent {
        "currentPage": number;
        "goToButtons": string;
        "hideEllipsis": boolean;
        "hideGotoEndButtons": boolean;
        "limit": number;
        "pageSize": number;
        "pageSizeOptions": Array<number | 'All'>;
        "paginationLayout": '' | 'start' | 'center' | 'end' | 'fill' | 'fill-left' | 'fill-right';
        "paginationVariantColor": string;
        "plumage": boolean;
        "position": 'top' | 'bottom' | 'both';
        "showDisplayRange": boolean;
        "showSizeChanger": boolean;
        "size": '' | 'sm' | 'lg';
        "tableId": string;
        "totalPages": number;
        "totalRows": number;
        "useByPagePagination": boolean;
        "useMinimizePagination": boolean;
    }
    interface PlumageInputFieldComponent {
        "disabled": boolean;
        "formId": string;
        "formLayout": '' | 'horizontal' | 'inline';
        "inputCol": number;
        "inputCols": string;
        "inputId": string;
        "label": string;
        "labelAlign": '' | 'right';
        /**
          * Legacy numeric cols (fallback)
         */
        "labelCol": number;
        /**
          * NEW: responsive column class specs (e.g., "col-sm-3 col-md-4" or "xs-12 sm-8")
         */
        "labelCols": string;
        "labelHidden": boolean;
        "labelSize": '' | 'sm' | 'lg';
        "placeholder"?: string;
        "required": boolean;
        "size": '' | 'sm' | 'lg';
        "type": string;
        "validation": boolean;
        "validationMessage": string;
        "value": string;
    }
    interface PlumageTimepickerComponent {
        /**
          * Accessible label for the input
         */
        "ariaLabel": string;
        /**
          * ID of the external label element (for aria-labelledby)
         */
        "ariaLabelledby": string;
        /**
          * (Used in Lit markup for underline states)
         */
        "disabled"?: boolean;
        /**
          * Force-validate and sync input -> dropdown
         */
        "forceTimeUpdate": () => Promise<void>;
        "forceTimeUpdatePublic": () => Promise<void>;
        /**
          * Hide seconds UI / value
         */
        "hideSeconds": boolean;
        /**
          * Hide the toggle/launch button for the timepicker popover
         */
        "hideTimepickerBtn": boolean;
        /**
          * (Renamed from reserved `id`) ID passed to the internal input
         */
        "inputId": string;
        /**
          * Name attribute for the inner input
         */
        "inputName": string;
        /**
          * Width (px) for the input element
         */
        "inputWidth"?: number | string;
        /**
          * Use 24-hour format by default (mutable: toggled by the component)
         */
        "isTwentyFourHourFormat": boolean;
        /**
          * Whether the current value is considered valid (mutable: set by validation)
         */
        "isValid": boolean;
        "labelText": string;
        "showLabel"?: boolean;
        /**
          * Optional size variant: '', 'sm', 'lg'
         */
        "size": string;
        /**
          * Force show only 12-hour controls/options
         */
        "twelveHourOnly": boolean;
        /**
          * Force show only 24-hour controls/options
         */
        "twentyFourHourOnly": boolean;
        /**
          * (Used in Lit markup for underline states)
         */
        "validation"?: boolean;
        /**
          * Validation message to show (mutable: set/cleared by the component)
         */
        "validationMessage": string;
    }
    interface PopoverComponent {
        "arrowOff": boolean;
        "content": string;
        "customClass": string;
        "fallbackPlacement": | 'flip'
    | 'clockwise'
    | 'counterclockwise'
    | 'auto'
    | 'top'
    | 'bottom'
    | 'left'
    | 'right'
    | 'topright'
    | 'topleft'
    | 'bottomright'
    | 'bottomleft'
    | 'lefttop'
    | 'leftbottom'
    | 'righttop'
    | 'rightbottom'
    | Array<
        | 'flip'
        | 'clockwise'
        | 'counterclockwise'
        | 'auto'
        | 'top'
        | 'bottom'
        | 'left'
        | 'right'
        | 'topright'
        | 'topleft'
        | 'bottomright'
        | 'bottomleft'
        | 'lefttop'
        | 'leftbottom'
        | 'righttop'
        | 'rightbottom'
      >;
        "offset": number;
        "placement": 'auto' | 'top' | 'bottom' | 'left' | 'right' | 'topright' | 'topleft' | 'bottomright' | 'bottomleft' | 'lefttop' | 'leftbottom' | 'righttop' | 'rightbottom';
        "plumage": boolean;
        /**
          * Keep external attribute name `title`, but avoid reserved prop name.
         */
        "popoverTitle": string;
        /**
          * Lit's `super` -> internal `superTooltip`, attribute remains `super`.
         */
        "superTooltip": boolean;
        /**
          * String id or direct HTMLElement
         */
        "target"?: string | HTMLElement;
        "trigger": 'click' | 'hover' | 'focus' | `${'click' | 'hover' | 'focus'} ${'click' | 'hover' | 'focus'}`;
        "variant": '' | 'primary' | 'secondary' | 'success' | 'danger' | 'info' | 'warning' | 'dark';
        "visible": boolean;
        "yOffset": number;
    }
    interface ProgressDisplayComponent {
        /**
          * Immutable public API
         */
        "animated": boolean;
        /**
          * Accepts JSON string (HTML attr) or array (JS)
         */
        "bars": | Array<{
        value: number;
        max?: number;
        variant?: '' | 'primary' | 'secondary' | 'success' | 'danger' | 'info' | 'warning' | 'dark';
        striped?: boolean;
        animated?: boolean;
        precision?: number;
        progressAlign?: '' | 'left' | 'right';
        showProgress?: boolean;
        showValue?: boolean;
      }>
    | string;
        "circular": boolean;
        "height": number;
        "indeterminate": boolean;
        "lineCap": boolean;
        "max": number;
        "multi": boolean;
        "precision": number;
        "progressAlign": '' | 'left' | 'right';
        "rotate"?: number;
        "showProgress": boolean;
        "showValue": boolean;
        "size": number;
        "striped": boolean;
        "strokeWidth": number;
        "styles": string;
        "value": number;
        "variant": '' | 'primary' | 'secondary' | 'success' | 'danger' | 'info' | 'warning' | 'dark';
    }
    interface RadioInputComponent {
        "customRadio": boolean;
        "customRadioGroup": boolean;
        "disabled": boolean;
        "groupOptions": any;
        "groupTitle": string;
        "groupTitleSize": string;
        "inline": boolean;
        "inputId": string;
        "labelTxt": string;
        "name": string;
        "radio": boolean;
        "radioGroup": boolean;
        "required": boolean;
        "size": string;
        "validation": boolean;
        "validationMsg": string;
        "value": string;
    }
    interface SelectFieldComponent {
        "classes": string;
        "custom": boolean;
        "defaultOptionTxt": string;
        "defaultTxt": string;
        "disabled": boolean;
        "formId": string;
        "formLayout": '' | 'horizontal' | 'inline';
        "inputCol": number;
        "inputCols": string;
        "label": string;
        "labelAlign": '' | 'right';
        /**
          * Legacy numeric cols (fallback)
         */
        "labelCol": number;
        /**
          * Responsive column class specs (e.g., "col", "col-sm-3 col-md-4", "xs-12 sm-6 md-4")
         */
        "labelCols": string;
        "labelHidden": boolean;
        "labelSize": '' | 'sm' | 'lg';
        "multiple": boolean;
        "options": Array<{ value: string; name: string }> | string;
        "required": boolean;
        /**
          * ID attribute for the <select> (Lit: selectFieldId)
         */
        "selectFieldId": string;
        "selected": boolean;
        "size": '' | 'sm' | 'lg';
        "validation": boolean;
        "validationMessage": string;
        "value": string;
        /**
          * When used with a table, sync with external sort events
         */
        "withTable": boolean;
    }
    interface SliderManagerComponent {
        "disabled": boolean;
        "hideLeftTextBox": boolean;
        "hideRightTextBox": boolean;
        "hideTextBoxes": boolean;
        "label": string;
        "lowerValue": number;
        "max": number;
        "min": number;
        "plumage": boolean;
        "selectedIndex": number;
        "sliderThumbLabel": boolean;
        "snapToTicks": boolean;
        "stringValues": string[];
        "tickLabels": boolean;
        "tickValues": number[];
        /**
          * 'basic' | 'multi' | 'discrete'
         */
        "type": 'basic' | 'multi' | 'discrete';
        "unit": string;
        "upperValue": number;
        "value": number;
        "variant": '' | 'primary' | 'secondary' | 'success' | 'danger' | 'info' | 'warning' | 'dark';
    }
    interface StandardPaginationComponent {
        "currentPage": number;
        "goToButtons": string;
        "hideEllipsis": boolean;
        "hideGotoEndButtons": boolean;
        "limit": number;
        "paginationLayout": '' | 'center' | 'end' | 'fill' | 'fill-left' | 'fill-right';
        "paginationVariantColor": string;
        "plumage": boolean;
        "size": '' | 'sm' | 'lg';
        "totalPages": number;
    }
    interface SvgComponent {
        /**
          * Fill color applied to slotted <svg>. Defaults to 'currentColor'.
         */
        "fill": string;
        /**
          * Height applied to slotted <svg> (px). Omit/0 to leave as-is.
         */
        "height"?: number;
        /**
          * Forwarded to the slotted <svg> as aria-hidden. Use "true" or "false". Using a different prop name avoids clashing with HTMLElement.ariaHidden.
         */
        "svgAriaHidden"?: 'true' | 'false';
        /**
          * Forwarded to the slotted <svg> as aria-label (avoids clashing with HTMLElement.ariaLabel).
         */
        "svgAriaLabel"?: string;
        /**
          * Optional margin wrapper around the slotted <svg>: '', 'left', or 'right'.
         */
        "svgMargin": '' | 'left' | 'right';
        /**
          * Width applied to slotted <svg> (px). Omit/0 to leave as-is.
         */
        "width"?: number;
    }
    interface TableComponent {
        "border": boolean;
        "bordered": boolean;
        "borderless": boolean;
        "caption": '' | 'top' | 'bottom';
        "cloneFooter": boolean;
        "currentPage": number;
        "dark": boolean;
        "dropdownId": string;
        "expandedRows": number[];
        "fields": Field[];
        "filterText": string;
        "fixed": boolean;
        "goToButtons": string;
        "headerDark": boolean;
        "headerLight": boolean;
        "hideEllipsis": boolean;
        "hideGotoEndButtons": boolean;
        "hover": boolean;
        "items": any[];
        "noBorderCollapsed": boolean;
        "originalItems": any[];
        "pageSizeOptions": Array<number | 'All'>;
        "paginationLayout": string;
        "paginationLimit": number;
        "paginationPosition": 'top' | 'bottom' | 'both';
        "paginationSize": '' | 'sm' | 'lg';
        "paginationVariantColor": string;
        "plumage": boolean;
        "resetSort": () => Promise<void>;
        "responsive": boolean;
        "rowsPerPage": number;
        "selectMode": SelectMode;
        "selectedFilterFields": string[];
        "selectedRows": any[];
        "selectedVariant": string;
        "showDisplayRange": boolean;
        "showSizeChanger": boolean;
        "size": '' | 'sm';
        "sortCriteria": Array<{ key: string; order: SortOrder | 'none' }>;
        "sortField": string;
        "sortOrder": SortOrder;
        "sortOrderDisabled": boolean;
        "sortable": boolean;
        "stacked": boolean;
        "sticky": boolean;
        "striped": boolean;
        "tableId": string;
        "tableVariant": Variant | 'table';
        "totalRows": number;
        "useByPagePagination": boolean;
        "useMinimizePagination": boolean;
        "usePagination": boolean;
    }
    interface TimepickerComponent {
        /**
          * Accessible label for the input
         */
        "ariaLabel": string;
        /**
          * ID of the external label element (for aria-labelledby)
         */
        "ariaLabelledby": string;
        /**
          * Force-validate and sync input -> dropdown
         */
        "forceTimeUpdate": () => Promise<void>;
        /**
          * Hide seconds UI / value
         */
        "hideSeconds": boolean;
        /**
          * Hide the toggle/launch button for the timepicker popover
         */
        "hideTimepickerBtn": boolean;
        /**
          * (Renamed from reserved `id`) ID passed to the internal input
         */
        "inputId": string;
        /**
          * Name attribute for the inner input
         */
        "inputName": string;
        /**
          * Width (px) for the input element
         */
        "inputWidth"?: number | string;
        /**
          * Use 24-hour format by default (mutable: toggled by the component)
         */
        "isTwentyFourHourFormat": boolean;
        /**
          * Whether the current value is considered valid (mutable: set by validation)
         */
        "isValid": boolean;
        "labelText": string;
        "showLabel"?: boolean;
        /**
          * Optional size variant: '', 'sm', 'lg'
         */
        "size": string;
        /**
          * Force show only 12-hour controls/options
         */
        "twelveHourOnly": boolean;
        /**
          * Force show only 24-hour controls/options
         */
        "twentyFourHourOnly": boolean;
        /**
          * Validation message to show (mutable: set/cleared by the component)
         */
        "validationMessage": string;
    }
    interface TimepickerManager {
        /**
          * Accessible label for the input
         */
        "ariaLabel": string;
        /**
          * ID of the external label element (for aria-labelledby)
         */
        "ariaLabelledby": string;
        /**
          * Hide seconds UI / value
         */
        "hideSeconds": boolean;
        /**
          * Hide the toggle/launch button for the timepicker popover
         */
        "hideTimepickerBtn": boolean;
        /**
          * ID to pass to inner input(s)
         */
        "inputId": string;
        /**
          * Name attribute for the inner input
         */
        "inputName": string;
        /**
          * Width (px) for the input element
         */
        "inputWidth": number;
        /**
          * Use 24-hour format by default
         */
        "isTwentyFourHourFormat": boolean;
        /**
          * Whether the current value is considered valid
         */
        "isValid": boolean;
        "labelText": string;
        "showLabel"?: boolean;
        /**
          * Optional size variant (e.g., 'sm', 'lg')
         */
        "size": string;
        /**
          * Force show only 12-hour controls/options
         */
        "twelveHourOnly": boolean;
        /**
          * Force show only 24-hour controls/options
         */
        "twentyFourHourOnly": boolean;
        /**
          * Choose which implementation to render: false = <timepicker-component>, true = <plumage-timepicker-component>
         */
        "usePlTimepicker": boolean;
        /**
          * Validation message to show (if any)
         */
        "validationMessage": string;
    }
    interface ToastsComponent {
        /**
          * Optional header content (string/JSX) appearing next to the title (e.g., timestamp).
         */
        "additionalHeaderContent"?: any;
        /**
          * If true, new toasts append to the end; otherwise they prepend (newest on top).
         */
        "appendToast": boolean;
        "bodyClass"?: string;
        /**
          * Optional custom content for the body (string/JSX). Prefer using slots in apps.
         */
        "customContent"?: any;
        /**
          * Default lifespan in ms for auto-dismiss toasts.
         */
        "duration": number;
        /**
          * Default header/body helper classes.
         */
        "headerClass"?: string;
        /**
          * If true, use the â€œplumage iconâ€ layout on compact plumage variant.
         */
        "iconPlumageStyle": boolean;
        /**
          * When true, use polite/status instead of alert/assertive on aria-live for new toasts.
         */
        "isStatus": boolean;
        /**
          * Optional default message for simple string-only toasts.
         */
        "message"?: string;
        /**
          * Disable fade-in/out transitions globally.
         */
        "noAnimation": boolean;
        /**
          * If true, hide the Ã— close button by default.
         */
        "noCloseButton": boolean;
        /**
          * Prevent hover from pausing auto-hide globally.
         */
        "noHoverPause": boolean;
        /**
          * Make toasts persistent by default (no auto-hide).
         */
        "persistent": boolean;
        /**
          * If true, use the Plumage toast style.
         */
        "plumageToast": boolean;
        /**
          * If true with plumageToast, render the â€œmaxâ€ layout.
         */
        "plumageToastMax": boolean;
        /**
          * Where the toaster tray is anchored.
         */
        "position": ToastPosition;
        /**
          * Remove toast immediately.
         */
        "removeToast": (id: number) => Promise<void>;
        /**
          * Show a toast. Returns the id of the created toast.
         */
        "showToast": (opts?: Partial<Omit<ToastItem, "id" | "state">>) => Promise<number>;
        /**
          * If true, use the â€œsolidâ€ toast style (Bootstrap-like) instead of bordered.
         */
        "solidToast": boolean;
        /**
          * Start fade-out, then remove.
         */
        "startRemoveToast": (id: number) => Promise<void>;
        /**
          * Default icon symbol id (from the inline sprite) for new toasts.
         */
        "svgIcon"?: string;
        /**
          * Default time label (ZULU).
         */
        "time": string;
        /**
          * (Optional) id used inside nested elements; does not override the host element id
         */
        "toastId": string;
        /**
          * Optional default title for new toasts. (Renamed from reserved `title`.)
         */
        "toastTitle"?: string;
        /**
          * Variant color for new toasts (can be overridden per-toast via showToast opts).
         */
        "variant": ToastVariant;
    }
    interface ToggleSwitchComponent {
        "checked": boolean;
        "customSwitch": boolean;
        "disabled": boolean;
        "inline": boolean;
        "inputId": string;
        "labelTxt": string;
        "newToggleTxt": { on: string; off: string };
        "required": boolean;
        "size": string;
        "switches": boolean;
        "switchesArray": ToggleItem[];
        "toggleTxt": boolean;
        "validation": boolean;
        "validationMessage": string;
        "value": string;
    }
    interface TooltipComponent {
        /**
          * Enable/disable fade animation class
         */
        "animation": boolean;
        /**
          * Optional CSS selector to append tooltip into (defaults to body)
         */
        "container"?: string | null;
        /**
          * Additional classes to apply to tooltip; can be a string
         */
        "customClass": string;
        "hide": () => Promise<void>;
        /**
          * If true, treat content as HTML and use innerHTML (TRUSTED CONTENT ONLY)
         */
        "htmlContent": boolean;
        /**
          * Message fallback when no title/data-original-title supplied
         */
        "message": string;
        /**
          * Initial/forced placement; use "auto" to choose best fit
         */
        "position": TooltipPosition;
        "show": () => Promise<void>;
        /**
          * Title/content string; if empty, falls back to `title`/`data-original-title` attributes or `message`
         */
        "tooltipTitle"?: string;
        /**
          * Space-separated triggers: "hover", "focus", "click", "manual"
         */
        "trigger": string;
        /**
          * Contextual color variant
         */
        "variant": TooltipVariant;
        /**
          * If true, the tooltip is currently visible (manual control)
         */
        "visible": boolean;
    }
}
export interface AccordionComponentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAccordionComponentElement;
}
export interface AutocompleteMultipleSelectionsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAutocompleteMultipleSelectionsElement;
}
export interface AutocompleteMultiselectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAutocompleteMultiselectElement;
}
export interface AutocompleteSingleCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAutocompleteSingleElement;
}
export interface BadgeComponentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBadgeComponentElement;
}
export interface BasicSliderComponentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBasicSliderComponentElement;
}
export interface ButtonComponentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLButtonComponentElement;
}
export interface ByPagePaginationComponentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLByPagePaginationComponentElement;
}
export interface CardComponentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCardComponentElement;
}
export interface CheckboxComponentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCheckboxComponentElement;
}
export interface DiscreteSliderComponentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLDiscreteSliderComponentElement;
}
export interface DropdownComponentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLDropdownComponentElement;
}
export interface InputFieldComponentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLInputFieldComponentElement;
}
export interface InputGroupComponentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLInputGroupComponentElement;
}
export interface MinimizePaginationComponentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMinimizePaginationComponentElement;
}
export interface MultiRangeSliderComponentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMultiRangeSliderComponentElement;
}
export interface PaginationComponentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPaginationComponentElement;
}
export interface PlumageInputFieldComponentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPlumageInputFieldComponentElement;
}
export interface RadioInputComponentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRadioInputComponentElement;
}
export interface SelectFieldComponentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLSelectFieldComponentElement;
}
export interface StandardPaginationComponentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLStandardPaginationComponentElement;
}
export interface TableComponentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLTableComponentElement;
}
export interface ToggleSwitchComponentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLToggleSwitchComponentElement;
}
declare global {
    interface HTMLAccordionComponentElementEventMap {
        "toggleEvent": boolean;
    }
    interface HTMLAccordionComponentElement extends Components.AccordionComponent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAccordionComponentElementEventMap>(type: K, listener: (this: HTMLAccordionComponentElement, ev: AccordionComponentCustomEvent<HTMLAccordionComponentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAccordionComponentElementEventMap>(type: K, listener: (this: HTMLAccordionComponentElement, ev: AccordionComponentCustomEvent<HTMLAccordionComponentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAccordionComponentElement: {
        prototype: HTMLAccordionComponentElement;
        new (): HTMLAccordionComponentElement;
    };
    interface HTMLAccordionContainerElement extends Components.AccordionContainer, HTMLStencilElement {
    }
    var HTMLAccordionContainerElement: {
        prototype: HTMLAccordionContainerElement;
        new (): HTMLAccordionContainerElement;
    };
    interface HTMLAppWrapperElement extends Components.AppWrapper, HTMLStencilElement {
    }
    var HTMLAppWrapperElement: {
        prototype: HTMLAppWrapperElement;
        new (): HTMLAppWrapperElement;
    };
    interface HTMLAutocompleteMultipleSelectionsElementEventMap {
        "itemSelect": string;
        "clear": void;
        "componentError": { message: string; stack?: string };
        "multiSelectChange": string[];
        "optionDelete": string;
    }
    interface HTMLAutocompleteMultipleSelectionsElement extends Components.AutocompleteMultipleSelections, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAutocompleteMultipleSelectionsElementEventMap>(type: K, listener: (this: HTMLAutocompleteMultipleSelectionsElement, ev: AutocompleteMultipleSelectionsCustomEvent<HTMLAutocompleteMultipleSelectionsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAutocompleteMultipleSelectionsElementEventMap>(type: K, listener: (this: HTMLAutocompleteMultipleSelectionsElement, ev: AutocompleteMultipleSelectionsCustomEvent<HTMLAutocompleteMultipleSelectionsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAutocompleteMultipleSelectionsElement: {
        prototype: HTMLAutocompleteMultipleSelectionsElement;
        new (): HTMLAutocompleteMultipleSelectionsElement;
    };
    interface HTMLAutocompleteMultiselectElementEventMap {
        "itemSelect": string;
        "clear": void;
        "componentError": { message: string; stack?: string };
        "multiSelectChange": string[];
        "optionsChange": {
    options: string[];
    reason: 'add' | 'delete' | 'replace';
    value?: string; // the added/removed item, if applicable
  };
        "optionDelete": string;
    }
    interface HTMLAutocompleteMultiselectElement extends Components.AutocompleteMultiselect, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAutocompleteMultiselectElementEventMap>(type: K, listener: (this: HTMLAutocompleteMultiselectElement, ev: AutocompleteMultiselectCustomEvent<HTMLAutocompleteMultiselectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAutocompleteMultiselectElementEventMap>(type: K, listener: (this: HTMLAutocompleteMultiselectElement, ev: AutocompleteMultiselectCustomEvent<HTMLAutocompleteMultiselectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAutocompleteMultiselectElement: {
        prototype: HTMLAutocompleteMultiselectElement;
        new (): HTMLAutocompleteMultiselectElement;
    };
    interface HTMLAutocompleteSingleElementEventMap {
        "itemSelect": string;
        "clear": void;
        "componentError": { message: string; stack?: string };
    }
    interface HTMLAutocompleteSingleElement extends Components.AutocompleteSingle, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAutocompleteSingleElementEventMap>(type: K, listener: (this: HTMLAutocompleteSingleElement, ev: AutocompleteSingleCustomEvent<HTMLAutocompleteSingleElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAutocompleteSingleElementEventMap>(type: K, listener: (this: HTMLAutocompleteSingleElement, ev: AutocompleteSingleCustomEvent<HTMLAutocompleteSingleElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAutocompleteSingleElement: {
        prototype: HTMLAutocompleteSingleElement;
        new (): HTMLAutocompleteSingleElement;
    };
    interface HTMLBadgeComponentElementEventMap {
        "customClick": any;
    }
    interface HTMLBadgeComponentElement extends Components.BadgeComponent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBadgeComponentElementEventMap>(type: K, listener: (this: HTMLBadgeComponentElement, ev: BadgeComponentCustomEvent<HTMLBadgeComponentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBadgeComponentElementEventMap>(type: K, listener: (this: HTMLBadgeComponentElement, ev: BadgeComponentCustomEvent<HTMLBadgeComponentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBadgeComponentElement: {
        prototype: HTMLBadgeComponentElement;
        new (): HTMLBadgeComponentElement;
    };
    interface HTMLBasicSliderComponentElementEventMap {
        "valueChange": { value: number };
    }
    interface HTMLBasicSliderComponentElement extends Components.BasicSliderComponent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBasicSliderComponentElementEventMap>(type: K, listener: (this: HTMLBasicSliderComponentElement, ev: BasicSliderComponentCustomEvent<HTMLBasicSliderComponentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBasicSliderComponentElementEventMap>(type: K, listener: (this: HTMLBasicSliderComponentElement, ev: BasicSliderComponentCustomEvent<HTMLBasicSliderComponentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBasicSliderComponentElement: {
        prototype: HTMLBasicSliderComponentElement;
        new (): HTMLBasicSliderComponentElement;
    };
    interface HTMLButtonComponentElementEventMap {
        "customClick": any;
    }
    interface HTMLButtonComponentElement extends Components.ButtonComponent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLButtonComponentElementEventMap>(type: K, listener: (this: HTMLButtonComponentElement, ev: ButtonComponentCustomEvent<HTMLButtonComponentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLButtonComponentElementEventMap>(type: K, listener: (this: HTMLButtonComponentElement, ev: ButtonComponentCustomEvent<HTMLButtonComponentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLButtonComponentElement: {
        prototype: HTMLButtonComponentElement;
        new (): HTMLButtonComponentElement;
    };
    interface HTMLButtonGroupElement extends Components.ButtonGroup, HTMLStencilElement {
    }
    var HTMLButtonGroupElement: {
        prototype: HTMLButtonGroupElement;
        new (): HTMLButtonGroupElement;
    };
    interface HTMLByPagePaginationComponentElementEventMap {
        "change-page": { page: number };
    }
    interface HTMLByPagePaginationComponentElement extends Components.ByPagePaginationComponent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLByPagePaginationComponentElementEventMap>(type: K, listener: (this: HTMLByPagePaginationComponentElement, ev: ByPagePaginationComponentCustomEvent<HTMLByPagePaginationComponentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLByPagePaginationComponentElementEventMap>(type: K, listener: (this: HTMLByPagePaginationComponentElement, ev: ByPagePaginationComponentCustomEvent<HTMLByPagePaginationComponentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLByPagePaginationComponentElement: {
        prototype: HTMLByPagePaginationComponentElement;
        new (): HTMLByPagePaginationComponentElement;
    };
    interface HTMLCardComponentElementEventMap {
        "customClick": any;
    }
    interface HTMLCardComponentElement extends Components.CardComponent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCardComponentElementEventMap>(type: K, listener: (this: HTMLCardComponentElement, ev: CardComponentCustomEvent<HTMLCardComponentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCardComponentElementEventMap>(type: K, listener: (this: HTMLCardComponentElement, ev: CardComponentCustomEvent<HTMLCardComponentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCardComponentElement: {
        prototype: HTMLCardComponentElement;
        new (): HTMLCardComponentElement;
    };
    interface HTMLCheckboxComponentElementEventMap {
        "groupChange": string[];
        "toggle": { checked: boolean; value: string; inputId: string };
    }
    interface HTMLCheckboxComponentElement extends Components.CheckboxComponent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCheckboxComponentElementEventMap>(type: K, listener: (this: HTMLCheckboxComponentElement, ev: CheckboxComponentCustomEvent<HTMLCheckboxComponentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCheckboxComponentElementEventMap>(type: K, listener: (this: HTMLCheckboxComponentElement, ev: CheckboxComponentCustomEvent<HTMLCheckboxComponentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCheckboxComponentElement: {
        prototype: HTMLCheckboxComponentElement;
        new (): HTMLCheckboxComponentElement;
    };
    interface HTMLDiscreteSliderComponentElementEventMap {
        "indexChange": { index: number };
        "valueChange": { value: string };
    }
    interface HTMLDiscreteSliderComponentElement extends Components.DiscreteSliderComponent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLDiscreteSliderComponentElementEventMap>(type: K, listener: (this: HTMLDiscreteSliderComponentElement, ev: DiscreteSliderComponentCustomEvent<HTMLDiscreteSliderComponentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLDiscreteSliderComponentElementEventMap>(type: K, listener: (this: HTMLDiscreteSliderComponentElement, ev: DiscreteSliderComponentCustomEvent<HTMLDiscreteSliderComponentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLDiscreteSliderComponentElement: {
        prototype: HTMLDiscreteSliderComponentElement;
        new (): HTMLDiscreteSliderComponentElement;
    };
    interface HTMLDividerComponentElement extends Components.DividerComponent, HTMLStencilElement {
    }
    var HTMLDividerComponentElement: {
        prototype: HTMLDividerComponentElement;
        new (): HTMLDividerComponentElement;
    };
    interface HTMLDropdownComponentElementEventMap {
        "itemSelected": any;
    }
    interface HTMLDropdownComponentElement extends Components.DropdownComponent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLDropdownComponentElementEventMap>(type: K, listener: (this: HTMLDropdownComponentElement, ev: DropdownComponentCustomEvent<HTMLDropdownComponentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLDropdownComponentElementEventMap>(type: K, listener: (this: HTMLDropdownComponentElement, ev: DropdownComponentCustomEvent<HTMLDropdownComponentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLDropdownComponentElement: {
        prototype: HTMLDropdownComponentElement;
        new (): HTMLDropdownComponentElement;
    };
    interface HTMLFormComponentElement extends Components.FormComponent, HTMLStencilElement {
    }
    var HTMLFormComponentElement: {
        prototype: HTMLFormComponentElement;
        new (): HTMLFormComponentElement;
    };
    interface HTMLIconComponentElement extends Components.IconComponent, HTMLStencilElement {
    }
    var HTMLIconComponentElement: {
        prototype: HTMLIconComponentElement;
        new (): HTMLIconComponentElement;
    };
    interface HTMLInputFieldComponentElementEventMap {
        "valueChange": string;
    }
    interface HTMLInputFieldComponentElement extends Components.InputFieldComponent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLInputFieldComponentElementEventMap>(type: K, listener: (this: HTMLInputFieldComponentElement, ev: InputFieldComponentCustomEvent<HTMLInputFieldComponentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLInputFieldComponentElementEventMap>(type: K, listener: (this: HTMLInputFieldComponentElement, ev: InputFieldComponentCustomEvent<HTMLInputFieldComponentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLInputFieldComponentElement: {
        prototype: HTMLInputFieldComponentElement;
        new (): HTMLInputFieldComponentElement;
    };
    interface HTMLInputGroupComponentElementEventMap {
        "valueChange": { value: string };
    }
    interface HTMLInputGroupComponentElement extends Components.InputGroupComponent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLInputGroupComponentElementEventMap>(type: K, listener: (this: HTMLInputGroupComponentElement, ev: InputGroupComponentCustomEvent<HTMLInputGroupComponentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLInputGroupComponentElementEventMap>(type: K, listener: (this: HTMLInputGroupComponentElement, ev: InputGroupComponentCustomEvent<HTMLInputGroupComponentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLInputGroupComponentElement: {
        prototype: HTMLInputGroupComponentElement;
        new (): HTMLInputGroupComponentElement;
    };
    interface HTMLMinimizePaginationComponentElementEventMap {
        "change-page": { page: number };
    }
    interface HTMLMinimizePaginationComponentElement extends Components.MinimizePaginationComponent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMinimizePaginationComponentElementEventMap>(type: K, listener: (this: HTMLMinimizePaginationComponentElement, ev: MinimizePaginationComponentCustomEvent<HTMLMinimizePaginationComponentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMinimizePaginationComponentElementEventMap>(type: K, listener: (this: HTMLMinimizePaginationComponentElement, ev: MinimizePaginationComponentCustomEvent<HTMLMinimizePaginationComponentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMinimizePaginationComponentElement: {
        prototype: HTMLMinimizePaginationComponentElement;
        new (): HTMLMinimizePaginationComponentElement;
    };
    interface HTMLModalComponentElement extends Components.ModalComponent, HTMLStencilElement {
    }
    var HTMLModalComponentElement: {
        prototype: HTMLModalComponentElement;
        new (): HTMLModalComponentElement;
    };
    interface HTMLMultiRangeSliderComponentElementEventMap {
        "rangeChange": { lowerValue: number; upperValue: number };
    }
    interface HTMLMultiRangeSliderComponentElement extends Components.MultiRangeSliderComponent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMultiRangeSliderComponentElementEventMap>(type: K, listener: (this: HTMLMultiRangeSliderComponentElement, ev: MultiRangeSliderComponentCustomEvent<HTMLMultiRangeSliderComponentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMultiRangeSliderComponentElementEventMap>(type: K, listener: (this: HTMLMultiRangeSliderComponentElement, ev: MultiRangeSliderComponentCustomEvent<HTMLMultiRangeSliderComponentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMultiRangeSliderComponentElement: {
        prototype: HTMLMultiRangeSliderComponentElement;
        new (): HTMLMultiRangeSliderComponentElement;
    };
    interface HTMLPaginationComponentElementEventMap {
        "page-changed": { page: number; pageSize: number };
        "page-size-changed": { pageSize: number };
    }
    interface HTMLPaginationComponentElement extends Components.PaginationComponent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPaginationComponentElementEventMap>(type: K, listener: (this: HTMLPaginationComponentElement, ev: PaginationComponentCustomEvent<HTMLPaginationComponentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPaginationComponentElementEventMap>(type: K, listener: (this: HTMLPaginationComponentElement, ev: PaginationComponentCustomEvent<HTMLPaginationComponentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPaginationComponentElement: {
        prototype: HTMLPaginationComponentElement;
        new (): HTMLPaginationComponentElement;
    };
    interface HTMLPlumageInputFieldComponentElementEventMap {
        "valueChange": string;
    }
    interface HTMLPlumageInputFieldComponentElement extends Components.PlumageInputFieldComponent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPlumageInputFieldComponentElementEventMap>(type: K, listener: (this: HTMLPlumageInputFieldComponentElement, ev: PlumageInputFieldComponentCustomEvent<HTMLPlumageInputFieldComponentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPlumageInputFieldComponentElementEventMap>(type: K, listener: (this: HTMLPlumageInputFieldComponentElement, ev: PlumageInputFieldComponentCustomEvent<HTMLPlumageInputFieldComponentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPlumageInputFieldComponentElement: {
        prototype: HTMLPlumageInputFieldComponentElement;
        new (): HTMLPlumageInputFieldComponentElement;
    };
    interface HTMLPlumageTimepickerComponentElement extends Components.PlumageTimepickerComponent, HTMLStencilElement {
    }
    var HTMLPlumageTimepickerComponentElement: {
        prototype: HTMLPlumageTimepickerComponentElement;
        new (): HTMLPlumageTimepickerComponentElement;
    };
    interface HTMLPopoverComponentElement extends Components.PopoverComponent, HTMLStencilElement {
    }
    var HTMLPopoverComponentElement: {
        prototype: HTMLPopoverComponentElement;
        new (): HTMLPopoverComponentElement;
    };
    interface HTMLProgressDisplayComponentElement extends Components.ProgressDisplayComponent, HTMLStencilElement {
    }
    var HTMLProgressDisplayComponentElement: {
        prototype: HTMLProgressDisplayComponentElement;
        new (): HTMLProgressDisplayComponentElement;
    };
    interface HTMLRadioInputComponentElementEventMap {
        "groupChange": string;
    }
    interface HTMLRadioInputComponentElement extends Components.RadioInputComponent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLRadioInputComponentElementEventMap>(type: K, listener: (this: HTMLRadioInputComponentElement, ev: RadioInputComponentCustomEvent<HTMLRadioInputComponentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLRadioInputComponentElementEventMap>(type: K, listener: (this: HTMLRadioInputComponentElement, ev: RadioInputComponentCustomEvent<HTMLRadioInputComponentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLRadioInputComponentElement: {
        prototype: HTMLRadioInputComponentElement;
        new (): HTMLRadioInputComponentElement;
    };
    interface HTMLSelectFieldComponentElementEventMap {
        "valueChange": { value: string };
    }
    interface HTMLSelectFieldComponentElement extends Components.SelectFieldComponent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLSelectFieldComponentElementEventMap>(type: K, listener: (this: HTMLSelectFieldComponentElement, ev: SelectFieldComponentCustomEvent<HTMLSelectFieldComponentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLSelectFieldComponentElementEventMap>(type: K, listener: (this: HTMLSelectFieldComponentElement, ev: SelectFieldComponentCustomEvent<HTMLSelectFieldComponentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLSelectFieldComponentElement: {
        prototype: HTMLSelectFieldComponentElement;
        new (): HTMLSelectFieldComponentElement;
    };
    interface HTMLSliderManagerComponentElement extends Components.SliderManagerComponent, HTMLStencilElement {
    }
    var HTMLSliderManagerComponentElement: {
        prototype: HTMLSliderManagerComponentElement;
        new (): HTMLSliderManagerComponentElement;
    };
    interface HTMLStandardPaginationComponentElementEventMap {
        "change-page": { page: number };
    }
    interface HTMLStandardPaginationComponentElement extends Components.StandardPaginationComponent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLStandardPaginationComponentElementEventMap>(type: K, listener: (this: HTMLStandardPaginationComponentElement, ev: StandardPaginationComponentCustomEvent<HTMLStandardPaginationComponentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLStandardPaginationComponentElementEventMap>(type: K, listener: (this: HTMLStandardPaginationComponentElement, ev: StandardPaginationComponentCustomEvent<HTMLStandardPaginationComponentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLStandardPaginationComponentElement: {
        prototype: HTMLStandardPaginationComponentElement;
        new (): HTMLStandardPaginationComponentElement;
    };
    interface HTMLSvgComponentElement extends Components.SvgComponent, HTMLStencilElement {
    }
    var HTMLSvgComponentElement: {
        prototype: HTMLSvgComponentElement;
        new (): HTMLSvgComponentElement;
    };
    interface HTMLTableComponentElementEventMap {
        "sort-field-updated": { value: string };
        "sort-order-updated": { value: string };
        "sort-changed": { field: string; order: string };
        "row-selected": any[];
    }
    interface HTMLTableComponentElement extends Components.TableComponent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLTableComponentElementEventMap>(type: K, listener: (this: HTMLTableComponentElement, ev: TableComponentCustomEvent<HTMLTableComponentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLTableComponentElementEventMap>(type: K, listener: (this: HTMLTableComponentElement, ev: TableComponentCustomEvent<HTMLTableComponentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLTableComponentElement: {
        prototype: HTMLTableComponentElement;
        new (): HTMLTableComponentElement;
    };
    interface HTMLTimepickerComponentElement extends Components.TimepickerComponent, HTMLStencilElement {
    }
    var HTMLTimepickerComponentElement: {
        prototype: HTMLTimepickerComponentElement;
        new (): HTMLTimepickerComponentElement;
    };
    interface HTMLTimepickerManagerElement extends Components.TimepickerManager, HTMLStencilElement {
    }
    var HTMLTimepickerManagerElement: {
        prototype: HTMLTimepickerManagerElement;
        new (): HTMLTimepickerManagerElement;
    };
    interface HTMLToastsComponentElement extends Components.ToastsComponent, HTMLStencilElement {
    }
    var HTMLToastsComponentElement: {
        prototype: HTMLToastsComponentElement;
        new (): HTMLToastsComponentElement;
    };
    interface HTMLToggleSwitchComponentElementEventMap {
        "checkedChanged": { id: string; checked: boolean };
    }
    interface HTMLToggleSwitchComponentElement extends Components.ToggleSwitchComponent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLToggleSwitchComponentElementEventMap>(type: K, listener: (this: HTMLToggleSwitchComponentElement, ev: ToggleSwitchComponentCustomEvent<HTMLToggleSwitchComponentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLToggleSwitchComponentElementEventMap>(type: K, listener: (this: HTMLToggleSwitchComponentElement, ev: ToggleSwitchComponentCustomEvent<HTMLToggleSwitchComponentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLToggleSwitchComponentElement: {
        prototype: HTMLToggleSwitchComponentElement;
        new (): HTMLToggleSwitchComponentElement;
    };
    interface HTMLTooltipComponentElement extends Components.TooltipComponent, HTMLStencilElement {
    }
    var HTMLTooltipComponentElement: {
        prototype: HTMLTooltipComponentElement;
        new (): HTMLTooltipComponentElement;
    };
    interface HTMLElementTagNameMap {
        "accordion-component": HTMLAccordionComponentElement;
        "accordion-container": HTMLAccordionContainerElement;
        "app-wrapper": HTMLAppWrapperElement;
        "autocomplete-multiple-selections": HTMLAutocompleteMultipleSelectionsElement;
        "autocomplete-multiselect": HTMLAutocompleteMultiselectElement;
        "autocomplete-single": HTMLAutocompleteSingleElement;
        "badge-component": HTMLBadgeComponentElement;
        "basic-slider-component": HTMLBasicSliderComponentElement;
        "button-component": HTMLButtonComponentElement;
        "button-group": HTMLButtonGroupElement;
        "by-page-pagination-component": HTMLByPagePaginationComponentElement;
        "card-component": HTMLCardComponentElement;
        "checkbox-component": HTMLCheckboxComponentElement;
        "discrete-slider-component": HTMLDiscreteSliderComponentElement;
        "divider-component": HTMLDividerComponentElement;
        "dropdown-component": HTMLDropdownComponentElement;
        "form-component": HTMLFormComponentElement;
        "icon-component": HTMLIconComponentElement;
        "input-field-component": HTMLInputFieldComponentElement;
        "input-group-component": HTMLInputGroupComponentElement;
        "minimize-pagination-component": HTMLMinimizePaginationComponentElement;
        "modal-component": HTMLModalComponentElement;
        "multi-range-slider-component": HTMLMultiRangeSliderComponentElement;
        "pagination-component": HTMLPaginationComponentElement;
        "plumage-input-field-component": HTMLPlumageInputFieldComponentElement;
        "plumage-timepicker-component": HTMLPlumageTimepickerComponentElement;
        "popover-component": HTMLPopoverComponentElement;
        "progress-display-component": HTMLProgressDisplayComponentElement;
        "radio-input-component": HTMLRadioInputComponentElement;
        "select-field-component": HTMLSelectFieldComponentElement;
        "slider-manager-component": HTMLSliderManagerComponentElement;
        "standard-pagination-component": HTMLStandardPaginationComponentElement;
        "svg-component": HTMLSvgComponentElement;
        "table-component": HTMLTableComponentElement;
        "timepicker-component": HTMLTimepickerComponentElement;
        "timepicker-manager": HTMLTimepickerManagerElement;
        "toasts-component": HTMLToastsComponentElement;
        "toggle-switch-component": HTMLToggleSwitchComponentElement;
        "tooltip-component": HTMLTooltipComponentElement;
    }
}
declare namespace LocalJSX {
    interface AccordionComponent {
        "accordion"?: boolean;
        "block"?: boolean;
        "classNames"?: string;
        "contentTxtSize"?: string;
        "disabled"?: boolean;
        "flush"?: boolean;
        "icon"?: string;
        "isOpen"?: boolean;
        "link"?: boolean;
        "onToggleEvent"?: (event: AccordionComponentCustomEvent<boolean>) => void;
        "outlined"?: boolean;
        "ripple"?: boolean;
        "size"?: string;
        "targetId"?: string;
        "variant"?: string;
    }
    interface AccordionContainer {
        "block"?: boolean;
        "classNames"?: string;
        "contentTxtSize"?: string;
        "data"?: Array<{ header: string; content: string }>;
        "disabled"?: boolean;
        "flush"?: boolean;
        "icon"?: string;
        "outlined"?: boolean;
        "parentId"?: string;
        "ripple"?: boolean;
        "singleOpen"?: boolean;
        "size"?: string;
        "variant"?: string;
    }
    interface AppWrapper {
        /**
          * Optional classNames (e.g. bg-primary, p-4)
         */
        "classNames"?: string;
    }
    interface AutocompleteMultipleSelections {
        "addBtn"?: boolean;
        "addIcon"?: string;
        "addNewOnEnter"?: boolean;
        "arialabelledBy"?: string;
        "autoSort"?: boolean;
        "badgeInlineStyles"?: string;
        "badgeShape"?: string;
        "badgeVariant"?: string;
        "clearIcon"?: string;
        "clearInputOnBlurOutside"?: boolean;
        "devMode"?: boolean;
        "disabled"?: boolean;
        "editable"?: boolean;
        "error"?: boolean;
        "errorMessage"?: string;
        "formId"?: string;
        "formLayout"?: '' | 'horizontal' | 'inline';
        "inputCol"?: number;
        "inputCols"?: string;
        "inputId"?: string;
        "label"?: string;
        "labelAlign"?: '' | 'right';
        "labelCol"?: number;
        /**
          * Responsive columns (e.g., "col", "col-sm-3 col-md-4", "xs-12 sm-6 md-4")
         */
        "labelCols"?: string;
        "labelHidden"?: boolean;
        "labelSize"?: '' | 'sm' | 'lg';
        /**
          * Field name for selected items; if it ends with [] one input per item is emitted.
         */
        "name"?: string;
        "onClear"?: (event: AutocompleteMultipleSelectionsCustomEvent<void>) => void;
        "onComponentError"?: (event: AutocompleteMultipleSelectionsCustomEvent<{ message: string; stack?: string }>) => void;
        "onItemSelect"?: (event: AutocompleteMultipleSelectionsCustomEvent<string>) => void;
        "onMultiSelectChange"?: (event: AutocompleteMultipleSelectionsCustomEvent<string[]>) => void;
        "onOptionDelete"?: (event: AutocompleteMultipleSelectionsCustomEvent<string>) => void;
        "options"?: string[];
        "placeholder"?: string;
        "preserveInputOnSelect"?: boolean;
        /**
          * Also submit whatever the user typed under this name (verbatim).
         */
        "rawInputName"?: string;
        "removeBtnBorder"?: boolean;
        "removeClearBtn"?: boolean;
        "required"?: boolean;
        "size"?: '' | 'sm' | 'lg';
        "type"?: string;
        "validation"?: boolean;
        "validationMessage"?: string;
    }
    interface AutocompleteMultiselect {
        "addBtn"?: boolean;
        "addIcon"?: string;
        "addNewOnEnter"?: boolean;
        "arialabelledBy"?: string;
        "autoSort"?: boolean;
        "badgeInlineStyles"?: string;
        "badgeShape"?: string;
        "badgeVariant"?: string;
        "clearIcon"?: string;
        "clearInputOnBlurOutside"?: boolean;
        "devMode"?: boolean;
        "disabled"?: boolean;
        "editable"?: boolean;
        "error"?: boolean;
        "errorMessage"?: string;
        "formId"?: string;
        "formLayout"?: '' | 'horizontal' | 'inline';
        "inputCol"?: number;
        "inputCols"?: string;
        "inputId"?: string;
        "label"?: string;
        "labelAlign"?: '' | 'right';
        "labelCol"?: number;
        /**
          * Responsive column class specs (e.g., "col", "col-sm-3 col-md-4", or "xs-12 sm-6 md-4")
         */
        "labelCols"?: string;
        "labelHidden"?: boolean;
        "labelSize"?: '' | 'sm' | 'lg';
        "name"?: string;
        "onClear"?: (event: AutocompleteMultiselectCustomEvent<void>) => void;
        "onComponentError"?: (event: AutocompleteMultiselectCustomEvent<{ message: string; stack?: string }>) => void;
        "onItemSelect"?: (event: AutocompleteMultiselectCustomEvent<string>) => void;
        "onMultiSelectChange"?: (event: AutocompleteMultiselectCustomEvent<string[]>) => void;
        "onOptionDelete"?: (event: AutocompleteMultiselectCustomEvent<string>) => void;
        /**
          * ðŸ”” Hook for hosts to mirror/persist options
         */
        "onOptionsChange"?: (event: AutocompleteMultiselectCustomEvent<{
    options: string[];
    reason: 'add' | 'delete' | 'replace';
    value?: string; // the added/removed item, if applicable
  }>) => void;
        "options"?: string[];
        "placeholder"?: string;
        "preserveInputOnSelect"?: boolean;
        "rawInputName"?: string;
        "removeClearBtn"?: boolean;
        "required"?: boolean;
        "size"?: '' | 'sm' | 'lg';
        "type"?: string;
        "validation"?: boolean;
        "validationMessage"?: string;
    }
    interface AutocompleteSingle {
        "arialabelledBy"?: string;
        "autoSort"?: boolean;
        "clearIcon"?: string;
        "devMode"?: boolean;
        "disabled"?: boolean;
        "error"?: boolean;
        "errorMessage"?: string;
        "formId"?: string;
        "formLayout"?: '' | 'horizontal' | 'inline';
        "inputCol"?: number;
        "inputCols"?: string;
        "inputId"?: string;
        "label"?: string;
        "labelAlign"?: '' | 'right';
        /**
          * Back-compat numeric columns (used only if labelCols/inputCols are not provided)
         */
        "labelCol"?: number;
        /**
          * Responsive column class specs (e.g., "col", "col-sm-3 col-md-4", or "xs-12 sm-6 md-4")
         */
        "labelCols"?: string;
        "labelHidden"?: boolean;
        "labelSize"?: '' | 'sm' | 'lg';
        "onClear"?: (event: AutocompleteSingleCustomEvent<void>) => void;
        "onComponentError"?: (event: AutocompleteSingleCustomEvent<{ message: string; stack?: string }>) => void;
        "onItemSelect"?: (event: AutocompleteSingleCustomEvent<string>) => void;
        "options"?: string[];
        "placeholder"?: string;
        "removeClearBtn"?: boolean;
        "required"?: boolean;
        "size"?: '' | 'sm' | 'lg';
        "type"?: string;
        "validation"?: boolean;
        "validationMessage"?: string;
    }
    interface BadgeComponent {
        "absolute"?: boolean;
        "ariaDescribedby"?: string;
        "ariaLabelledby"?: string;
        "backgroundColor"?: string;
        "bdgPosition"?: string;
        "bordered"?: boolean;
        "bottom"?: string;
        "classNames"?: string;
        "color"?: string;
        "devMode"?: boolean;
        "disabled"?: boolean;
        "dot"?: boolean;
        "elevation"?: string;
        "icon"?: boolean;
        "inlineStyles"?: string;
        "inset"?: boolean;
        "label"?: string;
        "left"?: string;
        "offsetX"?: string;
        "offsetY"?: string;
        "onCustomClick"?: (event: BadgeComponentCustomEvent<any>) => void;
        "outlined"?: boolean;
        "pulse"?: boolean;
        "right"?: string;
        "shape"?: string;
        "size"?: string;
        "styles"?: string;
        "token"?: boolean;
        "top"?: string;
        "variant"?: string;
        "zIndex"?: string;
    }
    interface BasicSliderComponent {
        "disabled"?: boolean;
        "hideLeftTextBox"?: boolean;
        "hideRightTextBox"?: boolean;
        "hideTextBoxes"?: boolean;
        "label"?: string;
        "max"?: number;
        "min"?: number;
        "onValueChange"?: (event: BasicSliderComponentCustomEvent<{ value: number }>) => void;
        "plumage"?: boolean;
        "sliderThumbLabel"?: boolean;
        "snapToTicks"?: boolean;
        "tickLabels"?: boolean;
        /**
          * Accepts array or JSON string in HTML
         */
        "tickValues"?: number[] | string;
        "ticks"?: number | '';
        "unit"?: string;
        "value"?: number;
        "variant"?: '' | 'primary' | 'secondary' | 'success' | 'danger' | 'info' | 'warning' | 'dark';
    }
    interface ButtonComponent {
        "absolute"?: boolean;
        "accordion"?: boolean;
        "active"?: boolean;
        "ariaLabel"?: string;
        "block"?: boolean;
        "bottom"?: string;
        "btnIcon"?: boolean;
        "btnText"?: string;
        "classNames"?: string;
        "devMode"?: boolean;
        "disabled"?: boolean;
        "elevation"?: string;
        "end"?: boolean;
        "fixed"?: boolean;
        "groupBtn"?: boolean;
        "iconBtn"?: boolean;
        "isOpen"?: boolean;
        "left"?: string;
        "link"?: boolean;
        "onCustomClick"?: (event: ButtonComponentCustomEvent<any>) => void;
        "outlined"?: boolean;
        "pressed"?: boolean | string;
        "right"?: string;
        "ripple"?: boolean;
        "shape"?: string;
        "size"?: string;
        "slotSide"?: 'left' | 'right' | 'none';
        "start"?: boolean;
        "stripped"?: boolean;
        "styles"?: string;
        "targetId"?: string;
        "text"?: boolean;
        "textBtn"?: boolean;
        "titleAttr"?: string;
        "top"?: string;
        "url"?: string;
        "variant"?: string;
        "vertical"?: boolean;
        "zIndex"?: string;
    }
    interface ButtonGroup {
        "ariaLabel"?: string;
        "classNames"?: string;
        "vertical"?: boolean;
    }
    interface ByPagePaginationComponent {
        "controlId"?: string;
        "currentPage"?: number;
        "goToButtons"?: string;
        "onChange-page"?: (event: ByPagePaginationComponentCustomEvent<{ page: number }>) => void;
        "paginationLayout"?: '' | 'center' | 'end';
        "plumage"?: boolean;
        "size"?: '' | 'sm' | 'lg';
        "totalPages"?: number;
    }
    interface CardComponent {
        "actions"?: boolean;
        "altText"?: string;
        "ariaLabel"?: string;
        "cardMaxWidth"?: string;
        "classNames"?: string;
        "elevation"?: string;
        "img"?: boolean;
        "imgHeight"?: string;
        "imgSrc"?: string;
        "inlineStyles"?: string;
        "noFooter"?: boolean;
        "noHeader"?: boolean;
        "onCustomClick"?: (event: CardComponentCustomEvent<any>) => void;
        "tab"?: string;
    }
    interface CheckboxComponent {
        "checkbox"?: boolean;
        "checkboxGroup"?: boolean;
        "checked"?: boolean;
        "customCheckbox"?: boolean;
        "customCheckboxGroup"?: boolean;
        "disabled"?: boolean;
        "groupOptions"?: any;
        "groupTitle"?: string;
        "groupTitleSize"?: string;
        "inline"?: boolean;
        "inputId"?: string;
        "labelTxt"?: string;
        "name"?: string;
        "noPadding"?: boolean;
        "onGroupChange"?: (event: CheckboxComponentCustomEvent<string[]>) => void;
        "onToggle"?: (event: CheckboxComponentCustomEvent<{ checked: boolean; value: string; inputId: string }>) => void;
        "required"?: boolean;
        "size"?: string;
        "validation"?: boolean;
        "validationMsg"?: string;
        "value"?: string;
    }
    interface DiscreteSliderComponent {
        "disabled"?: boolean;
        "hideRightTextBox"?: boolean;
        "label"?: string;
        "onIndexChange"?: (event: DiscreteSliderComponentCustomEvent<{ index: number }>) => void;
        "onValueChange"?: (event: DiscreteSliderComponentCustomEvent<{ value: string }>) => void;
        "plumage"?: boolean;
        "selectedIndex"?: number;
        /**
          * Accepts array or JSON string in HTML
         */
        "stringValues"?: string[] | string;
        "tickLabels"?: boolean;
        "unit"?: string;
        "variant"?: '' | 'primary' | 'secondary' | 'success' | 'danger' | 'info' | 'warning' | 'dark';
    }
    interface DividerComponent {
        "dashed"?: boolean;
        "orientation"?: 'left' | 'right' | 'center';
        "orientationMargin"?: string;
        "plain"?: boolean;
        "styles"?: string;
        "type"?: 'horizontal' | 'vertical';
    }
    interface DropdownComponent {
        "alignMenuRight"?: boolean;
        "autoFocusSubmenu"?: boolean;
        "buttonText"?: string;
        "disabled"?: boolean;
        "icon"?: string;
        "iconDropdown"?: boolean;
        "iconSize"?: number;
        "inputId"?: string;
        "listType"?: string;
        "menuOffsetY"?: number;
        "name"?: string;
        "onItemSelected"?: (event: DropdownComponentCustomEvent<any>) => void;
        "options"?: DropdownItem[];
        "outlined"?: boolean;
        "ripple"?: boolean;
        "shape"?: string;
        "size"?: string;
        "subMenuListType"?: string;
        "submenuOffsetX"?: number;
        "tableId"?: string;
        "titleAttr"?: string;
        "value"?: string;
        "variant"?: string;
    }
    interface FormComponent {
        /**
          * Native form attributes
         */
        "action"?: string;
        /**
          * Optional border/box styling
         */
        "bcolor"?: string;
        "bradius"?: number;
        "bstyle"?: string;
        "bwidth"?: number;
        /**
          * Render a fieldset wrapper (with optional legend)
         */
        "fieldset"?: boolean;
        "formId"?: string;
        /**
          * Layout + identity used by slotted children
         */
        "formLayout"?: '' | 'horizontal' | 'inline';
        "legend"?: boolean;
        "legendPosition"?: 'left' | 'center' | 'right' | string;
        "legendTxt"?: string;
        "method"?: string;
        /**
          * If true, do not render a <form>. Inputs placed outside the form can still read formId via closest('form-component') and set their own form attribute.
         */
        "outsideOfForm"?: boolean;
        /**
          * Additional inline styles to append (CSS string)
         */
        "styles"?: string;
    }
    interface IconComponent {
        "color"?: string;
        "icon"?: string;
        "iconAriaHidden"?: boolean;
        "iconAriaLabel"?: string;
        "iconMargin"?: string;
        "iconSize"?: number;
        "size"?: string;
        "svg"?: boolean;
        "tokenIcon"?: boolean;
    }
    interface InputFieldComponent {
        "disabled"?: boolean;
        "formId"?: string;
        "formLayout"?: '' | 'horizontal' | 'inline';
        "inputCol"?: number;
        "inputCols"?: string;
        "inputId"?: string;
        "label"?: string;
        "labelAlign"?: '' | 'right';
        /**
          * Legacy numeric cols (fallback)
         */
        "labelCol"?: number;
        /**
          * NEW: responsive column class specs (e.g., "col", "col-sm-3 col-md-4", or "xs-12 sm-6 md-4")
         */
        "labelCols"?: string;
        "labelHidden"?: boolean;
        "labelSize"?: '' | 'sm' | 'lg';
        "onValueChange"?: (event: InputFieldComponentCustomEvent<string>) => void;
        "placeholder"?: string;
        "required"?: boolean;
        "size"?: '' | 'sm' | 'lg';
        "type"?: string;
        "validation"?: boolean;
        "validationMessage"?: string;
        "value"?: string;
    }
    interface InputGroupComponent {
        "appendIcon"?: string;
        "appendId"?: string;
        "disabled"?: boolean;
        "formId"?: string;
        "formLayout"?: '' | 'horizontal' | 'inline';
        "hasAppend"?: boolean;
        "hasPrepend"?: boolean;
        "icon"?: string;
        "inputCol"?: number;
        "inputCols"?: string;
        "inputId"?: string;
        /**
          * Kept for API parity; use `size` for visual sizing
         */
        "inputSize"?: string;
        "label"?: string;
        /**
          * Legacy numeric cols (fallback)
         */
        "labelCol"?: number;
        /**
          * NEW: responsive column class specs (e.g., "col", "col-sm-3 col-md-4", or "xs-12 sm-6 md-4")
         */
        "labelCols"?: string;
        "labelHidden"?: boolean;
        "labelSize"?: '' | 'sm' | 'lg';
        "onValueChange"?: (event: InputGroupComponentCustomEvent<{ value: string }>) => void;
        "otherContent"?: boolean;
        "placeholder"?: string;
        "prependIcon"?: string;
        "prependId"?: string;
        "required"?: boolean;
        "size"?: '' | 'sm' | 'lg';
        "type"?: string;
        "validation"?: boolean;
        "validationMessage"?: string;
        "value"?: string;
    }
    interface MinimizePaginationComponent {
        "controlId"?: string;
        "currentPage"?: number;
        "goToButtons"?: string;
        "onChange-page"?: (event: MinimizePaginationComponentCustomEvent<{ page: number }>) => void;
        "paginationLayout"?: '' | 'center' | 'end';
        "plumage"?: boolean;
        "size"?: '' | 'sm' | 'lg';
        "totalPages"?: number;
    }
    interface ModalComponent {
        "ariaLabel"?: string;
        "block"?: boolean;
        "btnText"?: string;
        "cancelCloseBtn"?: string;
        "classNames"?: string;
        "disabled"?: boolean;
        "link"?: boolean;
        "modalFullScreen"?: 'fullscreen' | 'sm-down' | 'md-down' | 'lg-down' | 'xl-down' | 'xxl-down';
        "modalId"?: string;
        "modalSize"?: 'sm' | 'lg' | 'xl';
        "modalTitle"?: string;
        "outlined"?: boolean;
        "ripple"?: boolean;
        "scrollLongContent"?: boolean;
        "scrollableBody"?: boolean;
        "shape"?: string;
        "size"?: string;
        "titleAttr"?: string;
        "variant"?: string;
        "verticallyCentered"?: boolean;
    }
    interface MultiRangeSliderComponent {
        "disabled"?: boolean;
        "hideLeftTextBox"?: boolean;
        "hideRightTextBox"?: boolean;
        "hideTextBoxes"?: boolean;
        "label"?: string;
        "lowerValue"?: number;
        "max"?: number;
        "min"?: number;
        "onRangeChange"?: (event: MultiRangeSliderComponentCustomEvent<{ lowerValue: number; upperValue: number }>) => void;
        "plumage"?: boolean;
        "sliderThumbLabel"?: boolean;
        "snapToTicks"?: boolean;
        "tickLabels"?: boolean;
        /**
          * Accepts array or JSON string in HTML
         */
        "tickValues"?: number[] | string;
        "unit"?: string;
        "upperValue"?: number;
        "variant"?: '' | 'primary' | 'secondary' | 'success' | 'danger' | 'info' | 'warning' | 'dark';
    }
    interface PaginationComponent {
        "currentPage"?: number;
        "goToButtons"?: string;
        "hideEllipsis"?: boolean;
        "hideGotoEndButtons"?: boolean;
        "limit"?: number;
        "onPage-changed"?: (event: PaginationComponentCustomEvent<{ page: number; pageSize: number }>) => void;
        "onPage-size-changed"?: (event: PaginationComponentCustomEvent<{ pageSize: number }>) => void;
        "pageSize"?: number;
        "pageSizeOptions"?: Array<number | 'All'>;
        "paginationLayout"?: '' | 'start' | 'center' | 'end' | 'fill' | 'fill-left' | 'fill-right';
        "paginationVariantColor"?: string;
        "plumage"?: boolean;
        "position"?: 'top' | 'bottom' | 'both';
        "showDisplayRange"?: boolean;
        "showSizeChanger"?: boolean;
        "size"?: '' | 'sm' | 'lg';
        "tableId"?: string;
        "totalPages"?: number;
        "totalRows"?: number;
        "useByPagePagination"?: boolean;
        "useMinimizePagination"?: boolean;
    }
    interface PlumageInputFieldComponent {
        "disabled"?: boolean;
        "formId"?: string;
        "formLayout"?: '' | 'horizontal' | 'inline';
        "inputCol"?: number;
        "inputCols"?: string;
        "inputId"?: string;
        "label"?: string;
        "labelAlign"?: '' | 'right';
        /**
          * Legacy numeric cols (fallback)
         */
        "labelCol"?: number;
        /**
          * NEW: responsive column class specs (e.g., "col-sm-3 col-md-4" or "xs-12 sm-8")
         */
        "labelCols"?: string;
        "labelHidden"?: boolean;
        "labelSize"?: '' | 'sm' | 'lg';
        "onValueChange"?: (event: PlumageInputFieldComponentCustomEvent<string>) => void;
        "placeholder"?: string;
        "required"?: boolean;
        "size"?: '' | 'sm' | 'lg';
        "type"?: string;
        "validation"?: boolean;
        "validationMessage"?: string;
        "value"?: string;
    }
    interface PlumageTimepickerComponent {
        /**
          * Accessible label for the input
         */
        "ariaLabel"?: string;
        /**
          * ID of the external label element (for aria-labelledby)
         */
        "ariaLabelledby"?: string;
        /**
          * (Used in Lit markup for underline states)
         */
        "disabled"?: boolean;
        /**
          * Hide seconds UI / value
         */
        "hideSeconds"?: boolean;
        /**
          * Hide the toggle/launch button for the timepicker popover
         */
        "hideTimepickerBtn"?: boolean;
        /**
          * (Renamed from reserved `id`) ID passed to the internal input
         */
        "inputId"?: string;
        /**
          * Name attribute for the inner input
         */
        "inputName"?: string;
        /**
          * Width (px) for the input element
         */
        "inputWidth"?: number | string;
        /**
          * Use 24-hour format by default (mutable: toggled by the component)
         */
        "isTwentyFourHourFormat"?: boolean;
        /**
          * Whether the current value is considered valid (mutable: set by validation)
         */
        "isValid"?: boolean;
        "labelText"?: string;
        "showLabel"?: boolean;
        /**
          * Optional size variant: '', 'sm', 'lg'
         */
        "size"?: string;
        /**
          * Force show only 12-hour controls/options
         */
        "twelveHourOnly"?: boolean;
        /**
          * Force show only 24-hour controls/options
         */
        "twentyFourHourOnly"?: boolean;
        /**
          * (Used in Lit markup for underline states)
         */
        "validation"?: boolean;
        /**
          * Validation message to show (mutable: set/cleared by the component)
         */
        "validationMessage"?: string;
    }
    interface PopoverComponent {
        "arrowOff"?: boolean;
        "content"?: string;
        "customClass"?: string;
        "fallbackPlacement"?: | 'flip'
    | 'clockwise'
    | 'counterclockwise'
    | 'auto'
    | 'top'
    | 'bottom'
    | 'left'
    | 'right'
    | 'topright'
    | 'topleft'
    | 'bottomright'
    | 'bottomleft'
    | 'lefttop'
    | 'leftbottom'
    | 'righttop'
    | 'rightbottom'
    | Array<
        | 'flip'
        | 'clockwise'
        | 'counterclockwise'
        | 'auto'
        | 'top'
        | 'bottom'
        | 'left'
        | 'right'
        | 'topright'
        | 'topleft'
        | 'bottomright'
        | 'bottomleft'
        | 'lefttop'
        | 'leftbottom'
        | 'righttop'
        | 'rightbottom'
      >;
        "offset"?: number;
        "placement"?: 'auto' | 'top' | 'bottom' | 'left' | 'right' | 'topright' | 'topleft' | 'bottomright' | 'bottomleft' | 'lefttop' | 'leftbottom' | 'righttop' | 'rightbottom';
        "plumage"?: boolean;
        /**
          * Keep external attribute name `title`, but avoid reserved prop name.
         */
        "popoverTitle"?: string;
        /**
          * Lit's `super` -> internal `superTooltip`, attribute remains `super`.
         */
        "superTooltip"?: boolean;
        /**
          * String id or direct HTMLElement
         */
        "target"?: string | HTMLElement;
        "trigger"?: 'click' | 'hover' | 'focus' | `${'click' | 'hover' | 'focus'} ${'click' | 'hover' | 'focus'}`;
        "variant"?: '' | 'primary' | 'secondary' | 'success' | 'danger' | 'info' | 'warning' | 'dark';
        "visible"?: boolean;
        "yOffset"?: number;
    }
    interface ProgressDisplayComponent {
        /**
          * Immutable public API
         */
        "animated"?: boolean;
        /**
          * Accepts JSON string (HTML attr) or array (JS)
         */
        "bars"?: | Array<{
        value: number;
        max?: number;
        variant?: '' | 'primary' | 'secondary' | 'success' | 'danger' | 'info' | 'warning' | 'dark';
        striped?: boolean;
        animated?: boolean;
        precision?: number;
        progressAlign?: '' | 'left' | 'right';
        showProgress?: boolean;
        showValue?: boolean;
      }>
    | string;
        "circular"?: boolean;
        "height"?: number;
        "indeterminate"?: boolean;
        "lineCap"?: boolean;
        "max"?: number;
        "multi"?: boolean;
        "precision"?: number;
        "progressAlign"?: '' | 'left' | 'right';
        "rotate"?: number;
        "showProgress"?: boolean;
        "showValue"?: boolean;
        "size"?: number;
        "striped"?: boolean;
        "strokeWidth"?: number;
        "styles"?: string;
        "value"?: number;
        "variant"?: '' | 'primary' | 'secondary' | 'success' | 'danger' | 'info' | 'warning' | 'dark';
    }
    interface RadioInputComponent {
        "customRadio"?: boolean;
        "customRadioGroup"?: boolean;
        "disabled"?: boolean;
        "groupOptions"?: any;
        "groupTitle"?: string;
        "groupTitleSize"?: string;
        "inline"?: boolean;
        "inputId"?: string;
        "labelTxt"?: string;
        "name"?: string;
        "onGroupChange"?: (event: RadioInputComponentCustomEvent<string>) => void;
        "radio"?: boolean;
        "radioGroup"?: boolean;
        "required"?: boolean;
        "size"?: string;
        "validation"?: boolean;
        "validationMsg"?: string;
        "value"?: string;
    }
    interface SelectFieldComponent {
        "classes"?: string;
        "custom"?: boolean;
        "defaultOptionTxt"?: string;
        "defaultTxt"?: string;
        "disabled"?: boolean;
        "formId"?: string;
        "formLayout"?: '' | 'horizontal' | 'inline';
        "inputCol"?: number;
        "inputCols"?: string;
        "label"?: string;
        "labelAlign"?: '' | 'right';
        /**
          * Legacy numeric cols (fallback)
         */
        "labelCol"?: number;
        /**
          * Responsive column class specs (e.g., "col", "col-sm-3 col-md-4", "xs-12 sm-6 md-4")
         */
        "labelCols"?: string;
        "labelHidden"?: boolean;
        "labelSize"?: '' | 'sm' | 'lg';
        "multiple"?: boolean;
        "onValueChange"?: (event: SelectFieldComponentCustomEvent<{ value: string }>) => void;
        "options"?: Array<{ value: string; name: string }> | string;
        "required"?: boolean;
        /**
          * ID attribute for the <select> (Lit: selectFieldId)
         */
        "selectFieldId"?: string;
        "selected"?: boolean;
        "size"?: '' | 'sm' | 'lg';
        "validation"?: boolean;
        "validationMessage"?: string;
        "value"?: string;
        /**
          * When used with a table, sync with external sort events
         */
        "withTable"?: boolean;
    }
    interface SliderManagerComponent {
        "disabled"?: boolean;
        "hideLeftTextBox"?: boolean;
        "hideRightTextBox"?: boolean;
        "hideTextBoxes"?: boolean;
        "label"?: string;
        "lowerValue"?: number;
        "max"?: number;
        "min"?: number;
        "plumage"?: boolean;
        "selectedIndex"?: number;
        "sliderThumbLabel"?: boolean;
        "snapToTicks"?: boolean;
        "stringValues"?: string[];
        "tickLabels"?: boolean;
        "tickValues"?: number[];
        /**
          * 'basic' | 'multi' | 'discrete'
         */
        "type"?: 'basic' | 'multi' | 'discrete';
        "unit"?: string;
        "upperValue"?: number;
        "value"?: number;
        "variant"?: '' | 'primary' | 'secondary' | 'success' | 'danger' | 'info' | 'warning' | 'dark';
    }
    interface StandardPaginationComponent {
        "currentPage"?: number;
        "goToButtons"?: string;
        "hideEllipsis"?: boolean;
        "hideGotoEndButtons"?: boolean;
        "limit"?: number;
        "onChange-page"?: (event: StandardPaginationComponentCustomEvent<{ page: number }>) => void;
        "paginationLayout"?: '' | 'center' | 'end' | 'fill' | 'fill-left' | 'fill-right';
        "paginationVariantColor"?: string;
        "plumage"?: boolean;
        "size"?: '' | 'sm' | 'lg';
        "totalPages"?: number;
    }
    interface SvgComponent {
        /**
          * Fill color applied to slotted <svg>. Defaults to 'currentColor'.
         */
        "fill"?: string;
        /**
          * Height applied to slotted <svg> (px). Omit/0 to leave as-is.
         */
        "height"?: number;
        /**
          * Forwarded to the slotted <svg> as aria-hidden. Use "true" or "false". Using a different prop name avoids clashing with HTMLElement.ariaHidden.
         */
        "svgAriaHidden"?: 'true' | 'false';
        /**
          * Forwarded to the slotted <svg> as aria-label (avoids clashing with HTMLElement.ariaLabel).
         */
        "svgAriaLabel"?: string;
        /**
          * Optional margin wrapper around the slotted <svg>: '', 'left', or 'right'.
         */
        "svgMargin"?: '' | 'left' | 'right';
        /**
          * Width applied to slotted <svg> (px). Omit/0 to leave as-is.
         */
        "width"?: number;
    }
    interface TableComponent {
        "border"?: boolean;
        "bordered"?: boolean;
        "borderless"?: boolean;
        "caption"?: '' | 'top' | 'bottom';
        "cloneFooter"?: boolean;
        "currentPage"?: number;
        "dark"?: boolean;
        "dropdownId"?: string;
        "expandedRows"?: number[];
        "fields"?: Field[];
        "filterText"?: string;
        "fixed"?: boolean;
        "goToButtons"?: string;
        "headerDark"?: boolean;
        "headerLight"?: boolean;
        "hideEllipsis"?: boolean;
        "hideGotoEndButtons"?: boolean;
        "hover"?: boolean;
        "items"?: any[];
        "noBorderCollapsed"?: boolean;
        "onRow-selected"?: (event: TableComponentCustomEvent<any[]>) => void;
        "onSort-changed"?: (event: TableComponentCustomEvent<{ field: string; order: string }>) => void;
        "onSort-field-updated"?: (event: TableComponentCustomEvent<{ value: string }>) => void;
        "onSort-order-updated"?: (event: TableComponentCustomEvent<{ value: string }>) => void;
        "originalItems"?: any[];
        "pageSizeOptions"?: Array<number | 'All'>;
        "paginationLayout"?: string;
        "paginationLimit"?: number;
        "paginationPosition"?: 'top' | 'bottom' | 'both';
        "paginationSize"?: '' | 'sm' | 'lg';
        "paginationVariantColor"?: string;
        "plumage"?: boolean;
        "responsive"?: boolean;
        "rowsPerPage"?: number;
        "selectMode"?: SelectMode;
        "selectedFilterFields"?: string[];
        "selectedRows"?: any[];
        "selectedVariant"?: string;
        "showDisplayRange"?: boolean;
        "showSizeChanger"?: boolean;
        "size"?: '' | 'sm';
        "sortCriteria"?: Array<{ key: string; order: SortOrder | 'none' }>;
        "sortField"?: string;
        "sortOrder"?: SortOrder;
        "sortOrderDisabled"?: boolean;
        "sortable"?: boolean;
        "stacked"?: boolean;
        "sticky"?: boolean;
        "striped"?: boolean;
        "tableId"?: string;
        "tableVariant"?: Variant | 'table';
        "totalRows"?: number;
        "useByPagePagination"?: boolean;
        "useMinimizePagination"?: boolean;
        "usePagination"?: boolean;
    }
    interface TimepickerComponent {
        /**
          * Accessible label for the input
         */
        "ariaLabel"?: string;
        /**
          * ID of the external label element (for aria-labelledby)
         */
        "ariaLabelledby"?: string;
        /**
          * Hide seconds UI / value
         */
        "hideSeconds"?: boolean;
        /**
          * Hide the toggle/launch button for the timepicker popover
         */
        "hideTimepickerBtn"?: boolean;
        /**
          * (Renamed from reserved `id`) ID passed to the internal input
         */
        "inputId"?: string;
        /**
          * Name attribute for the inner input
         */
        "inputName"?: string;
        /**
          * Width (px) for the input element
         */
        "inputWidth"?: number | string;
        /**
          * Use 24-hour format by default (mutable: toggled by the component)
         */
        "isTwentyFourHourFormat"?: boolean;
        /**
          * Whether the current value is considered valid (mutable: set by validation)
         */
        "isValid"?: boolean;
        "labelText"?: string;
        "showLabel"?: boolean;
        /**
          * Optional size variant: '', 'sm', 'lg'
         */
        "size"?: string;
        /**
          * Force show only 12-hour controls/options
         */
        "twelveHourOnly"?: boolean;
        /**
          * Force show only 24-hour controls/options
         */
        "twentyFourHourOnly"?: boolean;
        /**
          * Validation message to show (mutable: set/cleared by the component)
         */
        "validationMessage"?: string;
    }
    interface TimepickerManager {
        /**
          * Accessible label for the input
         */
        "ariaLabel"?: string;
        /**
          * ID of the external label element (for aria-labelledby)
         */
        "ariaLabelledby"?: string;
        /**
          * Hide seconds UI / value
         */
        "hideSeconds"?: boolean;
        /**
          * Hide the toggle/launch button for the timepicker popover
         */
        "hideTimepickerBtn"?: boolean;
        /**
          * ID to pass to inner input(s)
         */
        "inputId"?: string;
        /**
          * Name attribute for the inner input
         */
        "inputName"?: string;
        /**
          * Width (px) for the input element
         */
        "inputWidth"?: number;
        /**
          * Use 24-hour format by default
         */
        "isTwentyFourHourFormat"?: boolean;
        /**
          * Whether the current value is considered valid
         */
        "isValid"?: boolean;
        "labelText"?: string;
        "showLabel"?: boolean;
        /**
          * Optional size variant (e.g., 'sm', 'lg')
         */
        "size"?: string;
        /**
          * Force show only 12-hour controls/options
         */
        "twelveHourOnly"?: boolean;
        /**
          * Force show only 24-hour controls/options
         */
        "twentyFourHourOnly"?: boolean;
        /**
          * Choose which implementation to render: false = <timepicker-component>, true = <plumage-timepicker-component>
         */
        "usePlTimepicker"?: boolean;
        /**
          * Validation message to show (if any)
         */
        "validationMessage"?: string;
    }
    interface ToastsComponent {
        /**
          * Optional header content (string/JSX) appearing next to the title (e.g., timestamp).
         */
        "additionalHeaderContent"?: any;
        /**
          * If true, new toasts append to the end; otherwise they prepend (newest on top).
         */
        "appendToast"?: boolean;
        "bodyClass"?: string;
        /**
          * Optional custom content for the body (string/JSX). Prefer using slots in apps.
         */
        "customContent"?: any;
        /**
          * Default lifespan in ms for auto-dismiss toasts.
         */
        "duration"?: number;
        /**
          * Default header/body helper classes.
         */
        "headerClass"?: string;
        /**
          * If true, use the â€œplumage iconâ€ layout on compact plumage variant.
         */
        "iconPlumageStyle"?: boolean;
        /**
          * When true, use polite/status instead of alert/assertive on aria-live for new toasts.
         */
        "isStatus"?: boolean;
        /**
          * Optional default message for simple string-only toasts.
         */
        "message"?: string;
        /**
          * Disable fade-in/out transitions globally.
         */
        "noAnimation"?: boolean;
        /**
          * If true, hide the Ã— close button by default.
         */
        "noCloseButton"?: boolean;
        /**
          * Prevent hover from pausing auto-hide globally.
         */
        "noHoverPause"?: boolean;
        /**
          * Make toasts persistent by default (no auto-hide).
         */
        "persistent"?: boolean;
        /**
          * If true, use the Plumage toast style.
         */
        "plumageToast"?: boolean;
        /**
          * If true with plumageToast, render the â€œmaxâ€ layout.
         */
        "plumageToastMax"?: boolean;
        /**
          * Where the toaster tray is anchored.
         */
        "position"?: ToastPosition;
        /**
          * If true, use the â€œsolidâ€ toast style (Bootstrap-like) instead of bordered.
         */
        "solidToast"?: boolean;
        /**
          * Default icon symbol id (from the inline sprite) for new toasts.
         */
        "svgIcon"?: string;
        /**
          * Default time label (ZULU).
         */
        "time"?: string;
        /**
          * (Optional) id used inside nested elements; does not override the host element id
         */
        "toastId"?: string;
        /**
          * Optional default title for new toasts. (Renamed from reserved `title`.)
         */
        "toastTitle"?: string;
        /**
          * Variant color for new toasts (can be overridden per-toast via showToast opts).
         */
        "variant"?: ToastVariant;
    }
    interface ToggleSwitchComponent {
        "checked"?: boolean;
        "customSwitch"?: boolean;
        "disabled"?: boolean;
        "inline"?: boolean;
        "inputId"?: string;
        "labelTxt"?: string;
        "newToggleTxt"?: { on: string; off: string };
        "onCheckedChanged"?: (event: ToggleSwitchComponentCustomEvent<{ id: string; checked: boolean }>) => void;
        "required"?: boolean;
        "size"?: string;
        "switches"?: boolean;
        "switchesArray"?: ToggleItem[];
        "toggleTxt"?: boolean;
        "validation"?: boolean;
        "validationMessage"?: string;
        "value"?: string;
    }
    interface TooltipComponent {
        /**
          * Enable/disable fade animation class
         */
        "animation"?: boolean;
        /**
          * Optional CSS selector to append tooltip into (defaults to body)
         */
        "container"?: string | null;
        /**
          * Additional classes to apply to tooltip; can be a string
         */
        "customClass"?: string;
        /**
          * If true, treat content as HTML and use innerHTML (TRUSTED CONTENT ONLY)
         */
        "htmlContent"?: boolean;
        /**
          * Message fallback when no title/data-original-title supplied
         */
        "message"?: string;
        /**
          * Initial/forced placement; use "auto" to choose best fit
         */
        "position"?: TooltipPosition;
        /**
          * Title/content string; if empty, falls back to `title`/`data-original-title` attributes or `message`
         */
        "tooltipTitle"?: string;
        /**
          * Space-separated triggers: "hover", "focus", "click", "manual"
         */
        "trigger"?: string;
        /**
          * Contextual color variant
         */
        "variant"?: TooltipVariant;
        /**
          * If true, the tooltip is currently visible (manual control)
         */
        "visible"?: boolean;
    }
    interface IntrinsicElements {
        "accordion-component": AccordionComponent;
        "accordion-container": AccordionContainer;
        "app-wrapper": AppWrapper;
        "autocomplete-multiple-selections": AutocompleteMultipleSelections;
        "autocomplete-multiselect": AutocompleteMultiselect;
        "autocomplete-single": AutocompleteSingle;
        "badge-component": BadgeComponent;
        "basic-slider-component": BasicSliderComponent;
        "button-component": ButtonComponent;
        "button-group": ButtonGroup;
        "by-page-pagination-component": ByPagePaginationComponent;
        "card-component": CardComponent;
        "checkbox-component": CheckboxComponent;
        "discrete-slider-component": DiscreteSliderComponent;
        "divider-component": DividerComponent;
        "dropdown-component": DropdownComponent;
        "form-component": FormComponent;
        "icon-component": IconComponent;
        "input-field-component": InputFieldComponent;
        "input-group-component": InputGroupComponent;
        "minimize-pagination-component": MinimizePaginationComponent;
        "modal-component": ModalComponent;
        "multi-range-slider-component": MultiRangeSliderComponent;
        "pagination-component": PaginationComponent;
        "plumage-input-field-component": PlumageInputFieldComponent;
        "plumage-timepicker-component": PlumageTimepickerComponent;
        "popover-component": PopoverComponent;
        "progress-display-component": ProgressDisplayComponent;
        "radio-input-component": RadioInputComponent;
        "select-field-component": SelectFieldComponent;
        "slider-manager-component": SliderManagerComponent;
        "standard-pagination-component": StandardPaginationComponent;
        "svg-component": SvgComponent;
        "table-component": TableComponent;
        "timepicker-component": TimepickerComponent;
        "timepicker-manager": TimepickerManager;
        "toasts-component": ToastsComponent;
        "toggle-switch-component": ToggleSwitchComponent;
        "tooltip-component": TooltipComponent;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "accordion-component": LocalJSX.AccordionComponent & JSXBase.HTMLAttributes<HTMLAccordionComponentElement>;
            "accordion-container": LocalJSX.AccordionContainer & JSXBase.HTMLAttributes<HTMLAccordionContainerElement>;
            "app-wrapper": LocalJSX.AppWrapper & JSXBase.HTMLAttributes<HTMLAppWrapperElement>;
            "autocomplete-multiple-selections": LocalJSX.AutocompleteMultipleSelections & JSXBase.HTMLAttributes<HTMLAutocompleteMultipleSelectionsElement>;
            "autocomplete-multiselect": LocalJSX.AutocompleteMultiselect & JSXBase.HTMLAttributes<HTMLAutocompleteMultiselectElement>;
            "autocomplete-single": LocalJSX.AutocompleteSingle & JSXBase.HTMLAttributes<HTMLAutocompleteSingleElement>;
            "badge-component": LocalJSX.BadgeComponent & JSXBase.HTMLAttributes<HTMLBadgeComponentElement>;
            "basic-slider-component": LocalJSX.BasicSliderComponent & JSXBase.HTMLAttributes<HTMLBasicSliderComponentElement>;
            "button-component": LocalJSX.ButtonComponent & JSXBase.HTMLAttributes<HTMLButtonComponentElement>;
            "button-group": LocalJSX.ButtonGroup & JSXBase.HTMLAttributes<HTMLButtonGroupElement>;
            "by-page-pagination-component": LocalJSX.ByPagePaginationComponent & JSXBase.HTMLAttributes<HTMLByPagePaginationComponentElement>;
            "card-component": LocalJSX.CardComponent & JSXBase.HTMLAttributes<HTMLCardComponentElement>;
            "checkbox-component": LocalJSX.CheckboxComponent & JSXBase.HTMLAttributes<HTMLCheckboxComponentElement>;
            "discrete-slider-component": LocalJSX.DiscreteSliderComponent & JSXBase.HTMLAttributes<HTMLDiscreteSliderComponentElement>;
            "divider-component": LocalJSX.DividerComponent & JSXBase.HTMLAttributes<HTMLDividerComponentElement>;
            "dropdown-component": LocalJSX.DropdownComponent & JSXBase.HTMLAttributes<HTMLDropdownComponentElement>;
            "form-component": LocalJSX.FormComponent & JSXBase.HTMLAttributes<HTMLFormComponentElement>;
            "icon-component": LocalJSX.IconComponent & JSXBase.HTMLAttributes<HTMLIconComponentElement>;
            "input-field-component": LocalJSX.InputFieldComponent & JSXBase.HTMLAttributes<HTMLInputFieldComponentElement>;
            "input-group-component": LocalJSX.InputGroupComponent & JSXBase.HTMLAttributes<HTMLInputGroupComponentElement>;
            "minimize-pagination-component": LocalJSX.MinimizePaginationComponent & JSXBase.HTMLAttributes<HTMLMinimizePaginationComponentElement>;
            "modal-component": LocalJSX.ModalComponent & JSXBase.HTMLAttributes<HTMLModalComponentElement>;
            "multi-range-slider-component": LocalJSX.MultiRangeSliderComponent & JSXBase.HTMLAttributes<HTMLMultiRangeSliderComponentElement>;
            "pagination-component": LocalJSX.PaginationComponent & JSXBase.HTMLAttributes<HTMLPaginationComponentElement>;
            "plumage-input-field-component": LocalJSX.PlumageInputFieldComponent & JSXBase.HTMLAttributes<HTMLPlumageInputFieldComponentElement>;
            "plumage-timepicker-component": LocalJSX.PlumageTimepickerComponent & JSXBase.HTMLAttributes<HTMLPlumageTimepickerComponentElement>;
            "popover-component": LocalJSX.PopoverComponent & JSXBase.HTMLAttributes<HTMLPopoverComponentElement>;
            "progress-display-component": LocalJSX.ProgressDisplayComponent & JSXBase.HTMLAttributes<HTMLProgressDisplayComponentElement>;
            "radio-input-component": LocalJSX.RadioInputComponent & JSXBase.HTMLAttributes<HTMLRadioInputComponentElement>;
            "select-field-component": LocalJSX.SelectFieldComponent & JSXBase.HTMLAttributes<HTMLSelectFieldComponentElement>;
            "slider-manager-component": LocalJSX.SliderManagerComponent & JSXBase.HTMLAttributes<HTMLSliderManagerComponentElement>;
            "standard-pagination-component": LocalJSX.StandardPaginationComponent & JSXBase.HTMLAttributes<HTMLStandardPaginationComponentElement>;
            "svg-component": LocalJSX.SvgComponent & JSXBase.HTMLAttributes<HTMLSvgComponentElement>;
            "table-component": LocalJSX.TableComponent & JSXBase.HTMLAttributes<HTMLTableComponentElement>;
            "timepicker-component": LocalJSX.TimepickerComponent & JSXBase.HTMLAttributes<HTMLTimepickerComponentElement>;
            "timepicker-manager": LocalJSX.TimepickerManager & JSXBase.HTMLAttributes<HTMLTimepickerManagerElement>;
            "toasts-component": LocalJSX.ToastsComponent & JSXBase.HTMLAttributes<HTMLToastsComponentElement>;
            "toggle-switch-component": LocalJSX.ToggleSwitchComponent & JSXBase.HTMLAttributes<HTMLToggleSwitchComponentElement>;
            "tooltip-component": LocalJSX.TooltipComponent & JSXBase.HTMLAttributes<HTMLTooltipComponentElement>;
        }
    }
}
